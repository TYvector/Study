# 第4章 复合类型
## 4.1 数组
数组（array）是一种数据格式，能够存储多个同类型的值。计算机在内存中依次存储数组的各个元素。
数组声明应指出以下三点：
- 存储在每个元素中的值的类型；
- 数组名；
- 数组中的元素数。
在C++中，可以通过修改简单变量的声明，添加中括号（其中包含元素数目）来完成数组声明。
通用格式如下：
```
typeName arrayName[arraySize];
```
表达式arraySize指定元素数目，它必须是整型常数（如10）或const值，也可以是常量表达式（如8 * sizeof（int）），即其中所有的值在编译时都是已知的。
可以单独访问数组元素。方法是使用下标或索引来对元素进行编号。C++数组从0开始编号.C++使用带索引的方括号表示法来指定数组元素。注意，最后一个元素的索引比数组长度**小1**
```
#include <iostream>
int main()
{
    using namespace std;
    int yams[3];
    yam[0] = 7;
    yam[1] = 8;
    yam[2] = 6;
    int yamcosts[3] = {20 , 30 , 5};

    return 0;
}
```
### 4.1.1 程序说明
C++允许在声明语句中初始化数组元素。只需提供一个用逗号分隔的值列表（初始化列表），并将它们用花括号括起即可。
sizeof运算符返回类型或数据对象的长度（单位为字节）。注意，如果将sizeof运算符用于数组名，得到的将是整个数组中的字节数。但如果将sizeof用于数组元素，则得到的将是元素的长度（单位为字节）。
### 4.1.2 数组的初始化规则
只有在定义数组时才能使用初始化，此后就不能使用了，也不能将一个数组赋给另一个数组：
```
int cards[4] = {3,6,8,10};   //okay
int hands[4];               //okay
hands[4] = {5,6,7,9};       //not allowed
hands = cards;              //not allowed
```
可以使用下标分别给数组中的元素赋值。
初始化数组时，提供的值可以少于数组的元素数目。
如果只对数组的一部分进行初始化，则编译器将把其他元素设置为0。因此，将数组中所有的元素都初始化为0非常简单—只要显式地将第一个元素初始化为0，然后让编译器将其他元素都初始化为0即可：
```
long totals[500] = {0};
```
如果初始化数组时方括号内（[ ]）为空，C++编译器将计算元素个数。
### 4.1.3 C++11数组初始化方法
初始化数组时，可省略等号（=）
可不在大括号内包含任何东西，这将把所有元素都设置为零
```
double earnings[4] {1.2e4,1.6e4,1.1e4,1.7e4};
unsigned int counts[10] = {};
float balances[100]{};
```
列表初始化禁止缩窄转换
C++标准模板库（STL）提供了一种数组替代品—模板类vector，而C++11新增了模板类array。
## 4.2 字符串
字符串是存储在内存的连续字节中的一系列字符。C++处理字符串的方式有两种。第一种来自C语言，常被称为**C-风格字符串**（C-stylestring）。
以空字符（null character）结尾，空字符被写作\0，其ASCII码为0，用来标记字符串的结尾。
空字符对C-风格字符串而言至关重要。
不应将不是字符串的字符数组当作字符串来处理。
只需使用一个用引号括起的字符串即可，这种字符串被称为**字符串常量**（string constant）或**字符串字面值**（string literal）
```
char bird[11] = "Mr.Cheeps";
char fish[] = "Bubbles";
```
用引号括起的字符串隐式地包括结尾的空字符,各种C++输入工具通过键盘输入，将字符串读入到char数组中时，将自动加上结尾的空字符
应确保数组足够大，能够存储字符串中所有字符—包括空字符。使用字符串常量初始化字符数组是这样的一种情况，即让编译器计算元素数目更为安全。C++对字符串长度没有限制。
但"S"不是字符常量，它表示的是两个字符（字符S和\0）组成的字符串。更糟糕的是，"S"实际上表示的是字符串所在的内存地址。因此下面的语句试图将一个内存地址赋给shirt_size：
```
char shirt_size = "S";
```
由于地址在C++中是一种独立的类型，因此C++编译器不允许这种不合理的做法
### 4.2.1 拼接字符串常量
C++允许拼接字符串字面值，即将两个用引号括起的字符串合并为一个。任何两个由空白（空格、制表符和换行符）分隔的字符串常量都将自动拼接成一个。
拼接时不会在被连接的字符串之间添加空格，第二个字符串的第一个字符将紧跟在第一个字符串的最后一个字符（不考虑\0）后面。第一个字符串中的\0字符将被第二个字符串的第一个字符取代。
### 4.2.2 在数组中使用字符串
最常用的方法有两种—将数组初始化为字符串常量、将键盘或文件输入读入到数组中。
strlen( )函数返回的是存储在数组中的字符串的长度，而不是数组本身的长度。数组的长度不能短于strlen（ ）+1。
### 4.2.3 字符串输入
cin是如何确定已完成字符串输入呢？由于不能通过键盘输入空字符，因此cin需要用别的方法来确定字符串的结尾位置。cin使用空白（空格、制表符和换行符）来确定字符串的结束位置，这意味着cin在获取字符数组输入时只读取一个单词。读取该单词后，cin将该字符串放到数组中，并自动在结尾添加空字符。
另一个问题是，输入字符串可能比目标数组长。
### 4.2.4 每次读取一行字符串输入
每次读取一个单词通常不是最好的选择。具体地说，需要采用面向行而不是面向单词的方法。istream中的类（如cin）提供了一些面向行的类成员函数：getline( )和get( )。这两个函数都读取一行输入，直到到达换行符。随后getline( )将丢弃换行符，而get( )将换行符保留在输入序列中。
#### 面向行的输入：getline( )
getline( )函数读取整行，它使用通过回车键输入的换行符来确定输入结尾。要调用这种方法，可以使用cin.getline( )。该函数有两个参数。第一个参数是用来存储输入行的数组的名称，第二个参数是要读取的字符数。如果这个参数为20，则函数最多读取19个字符，余下的空间用于存储自动在结尾处添加的空字符。getline( )成员函数在读取指定数目的字符或遇到换行符时停止读取。

`cin.getine(name,20);`

#### 面向行的输入：get( )
istream类有另一个名为get( )的成员函数，该函数有几种变体。其中一种变体的工作方式与getline( )类似，它们接受的参数相同，解释参数的方式也相同，并且都读取到行尾。但get并不再读取并丢弃换行符，而是将其留在输入队列中。假设我们连续两次调用get( )：
由于第一次调用后，换行符将留在输入队列中，因此第二次调用时看到的第一个字符便是换行符。因此get( )认为已到达行尾，而没有发现任何可读取的内容。如果不借助于帮助，get( )将不能跨过该换行符。
使用不带任何参数的cin.get( )调用可读取下一个字符（即使是换行符），因此可以用它来处理换行符，为读取下一行输入做好准备。
```
cin.get(name,ArSize);
cin.get();
cin.get(dessert,ArSize);
```
另一种使用get( )的方式是将两个类成员函数拼接起来（合并）
```
cin.get(name,ArSize).get();
```
是由于cin.get（name，ArSize）返回一个cin对象，该对象随后将被用来调用get( )函数。
同样，下面的语句将把输入中连续的两行分别读入到数组name1和name2 中，其效果与两次调用cin.getline( )相同：
```
cin.getline(name1,ArSize).getline(name2,ArSize);
```
C++允许函数有多个版本，条件是这些版本的参数列表不同。
getline( )使用起来简单一些，但get( )使得检查错误更简单些。
#### 空行和其他问题
当get( )（不是getline( )）读取空行后将设置失效位（failbit）。这意味着接下来的输入将被阻断，但可以用下面的命令来恢复输入：
```
cin.clear();
```
如果输入行包含的字符数比指定的多，则getline( )和get( )将把余下的字符留在输入队列中，而getline( )还会设置失效位，并关闭后面的输入。
### 4.2.5 混合输入字符串和数字
当cin读取年份，将回车键生成的换行符留在了输入队列中。后面的cin.getline( )看到换行符后，将认为是一个空行，并将一个空字符串赋给address数组。解决之道是，在读取地址之前先读取并丢弃换行符。这可以通过几种方法来完成，其中包括使用没有参数的get( )和使用接受一个char参数的get( )，可以单独进行调用：
```
cin >> year;
cin.get(); // or cin.get(ch);
```
也可以利用表达式cin>>year返回cin对象，将调用拼接起来：
```
(cin >> year).get(); //or (cin>>year).get(ch);
```
C++程序常使用指针（而不是数组）来处理字符串。
## 4.3 string类简介
要使用string类，必须在程序中包含头文件string。string类位于名称空间std中，因此您必须提供一条using编译指令，或者使用std::string来引用它。string类定义隐藏了字符串的数组性质，让您能够像处理普通变量那样处理字符串。
在很多方面，使用string对象的方式与使用字符数组相同。
- 可以使用C-风格字符串来初始化string对象。
- 可以使用cin来将键盘输入存储到string对象中。
- 可以使用cout来显示string对象。
- 可以使用数组表示法来访问存储在string对象中的字符。
可以将string对象声明为简单变量，而不是数组
### 4.3.1 C++11字符串初始化
C++11也允许将列表初始化用于C-风格字符串和string对象
### 4.3.2 赋值、拼接和附加
不能将一个数组赋给另一个数组，但可以将一个string对象赋给另一个string对象：
string类简化了字符串合并操作。可以使用运算符+将两个string对象合并起来，还可以使用运算符+=将字符串附加到string对象的末尾。
### 4.3.3 string类的其他操作
头文件cstring（以前为string.h）提供了这些函数。可以使用
函数strcpy( )将字符串复制到字符数组中，使用函数strcat( )将字符串附加到字符数组末尾：
string类具有自动调整大小的功能。C函数库确实提供了与strcat( )和strcpy( )类似的函数—strncat( )和strncpy( )，它们接受指出目标数组最大允许长度的第三个参数
下面是两种确定字符串中字符数的方法：
```
int len1 = str1.size();
int len2 = strlen(charr1);
```
### 4.3.4 string类I/O
未初始化的数组的内容是未定义的；函数strlen( )从数组的第一个元素开始计算字节数，直到遇到空字符。
未被初始化的string对象的长度被自动设置为0。
下面是将一行输入读取到string对象中的代码
```
getline(cin,str);
```
### 4.3.5 其他形式的字符串字面值
除char类型外，C++还有类型wchar_t；而C++11新增了类型char16_t和char32_t。可创建这些类型的数组和这些类型的字符串字面值。C++分别使用前缀L、u和U表示，
C++使用前缀u8来表示UTF-8。
C++11新增的另一种类型是原始（raw）字符串。在原始字符串中，字符表示的就是自己，例如，序列\n不表示换行符，而表示两个常规字符—斜杠和n
原始字符串将"(和)"用作定界符，并使用前缀R来标识原始字符串：
原始字符串语法允许您在表示字符串开头的"和(之间添加其他字符，这意味着表示字符串结尾的"和)之间也必须包含这些字符。
自定义定界符时，在默认定界符之间添加任意数量的基本字符，但空格、左括号、右括号、斜杠和控制字符（如制表符和换行符）除外。
可将前缀R与其他字符串前缀结合使用
## 4.4 结构简介
结构是一种比数组更灵活的数据格式，因为同一个结构可以存储多种类型的数据
结构也是C++ OOP堡垒（类）的基石。
结构是用户定义的类型，而结构声明定义了这种类型的数据属性。定义了类型后，便可以创建这种类型的变量。因此创建结构包括两步。首先，**定义结构描述**—它描述并标记了能够存储在结构中的各种数据类型。然后按描述**创建结构变量**（结构数据对象）。
```
struct inflatable
{
    char name[20];
    float volume;
    double price;
}
```
关键字struct表明，这些代码定义的是一个结构的布局。标识符inflatable是这种数据格式的名称.这样，便可以像创建char或int类型的变量那样创建inflatable类型的变量了。接下来的大括号中包含的是结构存储的数据类型的列表，其中每个列表项都是一条声明语句。列表中的每一项都被称为结构成员，因此infatable结构有3个成员
定义结构后，便可以创建这种类型的变量了：
C++允许在声明结构变量时省略关键字struct,在C++中，结构标记的用法与基本类型名相同。
通过成员名能够访问结构的成员，就像通过索引能够访问数组的元素一样。
### 4.4.1 在程序中使用结构
```
#include <iostream>
struct inflatable
{
    char name[20];
    float volume;
    double price;
};

int main()
{
    using namespace std;
    inflatable guest =
    {
        "Glorious Gloria",
        1.88,
        2.99
    };

    inflatable pal = 
    {
        "Audacious Arthur",
        3.12,
        32.99
    };

    cout << guest.name << endl;
    cout << guest.price + pal.price << endl;

    return 0;
}
```
结构声明的位置很重要。有两种选择。可以将声明放在main( )函数中，紧跟在开始括号的后面。另一种选择是将声明放到main( )的前面，这里采用的便是这种方式，位于函数外面的声明被称为外部声明。外部声明可以被其后面的任何函数使用，而内部声明只能被该声明所属的函数使用。

变量也可以在函数内部和外部定义，外部变量由所有的函数共享.

和数组一样，使用由逗号分隔值列表，并将这些值用花括号括起。可将每个结构成员看作是相应类型的变量。
### 4.4.2 C++11结构初始化
与数组一样，C++11也支持将列表初始化用于结构，且等号（=）是可选的：
如果大括号内未包含任何东西，各个成员都将被设置为零。
最后，不允许缩窄转换。
### 4.4.3 结构可以将string类作为成员吗
答案是肯定的

一定要让结构定义能够访问名称空间std。为此，可以将编译指令using移到结构定义之前；也可以将name的类型声明为std::string。
### 4.4.4 其他结构属性
C++使用户定义的类型与内置类型尽可能相似。可以将结构作为参数传递给函数，也可以让函数返回一个结构。另外，还可以使用赋值运算符（=）将结构赋给另一个同类型的结构，这样结构中每个成员都将被设置为另一个结构中相应成员的值，即使成员是数组。这种赋值被称为**成员赋值**（memberwise assignment）

可以同时完成定义结构和创建结构变量的工作。为此，只需将变量名放在结束括号的后面即可：甚至可以初始化以这种方式创建的变量：

还可以声明没有名称的结构类型，方法是省略名称，同时定义一种结构类型和一个这种类型的变量
```
struct
{
    int x;
    int y;
} position;
```
### 4.4.5 结构数组
也可以创建元素为结构的数组，方法和创建基本类型数组完全相同。
```
inflatable gifts[100];
```
要初始化结构数组，可以结合使用初始化数组的规则（用逗号分隔每个元素的值，并将这些值用花括号括起）和初始化结构的规则（用逗号分隔每个成员的值，并将这些值用花括号括起）。最终结果为一个被括在花括号中、用逗号分隔的值列表，其中每个值本身又是一个被括在花括号中、用逗号分隔的值列表：
```
inflatable guest[2] = 
{
    {"Bambi",0.5,21.99},
    {"Godzilla",2000,565.99}
}
```
### 4.4.6 结构中的位字段
C++也允许指定占用特定位数的结构成员,字段的类型应为整型或枚举（稍后将介绍），接下来是冒号，冒号后面是一个数字，它指定了使用的位数。
```
struct torgle_register
{
    unsigned int SN : 4;
    unsigned int : 4;
    bool goodIn : 1;
    bool goodTorgle : 1;
}
```
## 4.5 共用体
共用体（union）是一种数据格式，它能够存储不同的数据类型，但只能同时存储其中的一种类型。也就是说，结构可以同时存储int、long和double，共用体只能存储int、long或double。共用体的句法与结构相似，但含义不同。
```
union one4all
{
    int int_val;
    long long_val;
    double double_val;
}
```
成员名称标识了变量的容量。由于共用体每次只能存储一个值，因此它必须有足够的空间来存储最大的成员，所以，共用体的长度为其最大成员的长度。
共用体的用途之一是，当数据项使用两种或更多种格式（但不会同时使用）时，可节省空间.
```
struct widget
{
    char brand[20];
    int type;
    union id
    {
        long id_num;
        char id_char[20];
    } id_val;
};
···
widget prize;
···
if (prize.type == 1)
    cin >> prize.id_val.id_num;
else
    cin >> prize.id_val.id_char;

```

匿名共用体（anonymous union）没有名称，其成员将成为位于相同地址处的变量。显然，每次只有一个成员是当前的成员：
```
struct widget
{
    char brand[20];
    int type;
    union
    {
        long id_num;
        char id_char[20];
    };
};
```
由于共用体是匿名的，因此id_num和id_char被视为prize的两个成员，它们的地址相同，所以不需要中间标识符id_val。
共用体常用于（但并非只能用于）节省内存。
## 4.6 枚举
C++的enum工具提供了另一种创建符号常量的方式，这种方式可以代替const。它还允许定义新类型，但必须按严格的限制进行。使用enum的句法与使用结构相似。
```
enum spectrum {red, orange, yellow, green, blue, violet, indigo, ultraviolet};
```
这条语句完成两项工作。
- 让spectrum成为新类型的名称；spectrum被称为**枚举**（enumeration），就像struct变量被称为结构一样。
- 将red、orange、yellow等作为符号常量，它们对应整数值0～7。这些常量叫作**枚举量**（enumerator）。
在默认情况下，将整数值赋给枚举量，第一个枚举量的值为0，第二个枚举量的值为1，依次类推。可以通过显式地指定整数值来覆盖默认值，可以用枚举名来声明这种类型的变量：
```
spectrum band;
```
在不进行强制类型转换的情况下，只能将定义枚举时使用的枚举量赋给这种枚举的变量，因此，spectrum变量受到限制，只有8个可能的值。对于枚举，只定义了赋值运算符。具体地说，没有为枚举定义算术运算
```
band = blue;
band = orange;
```
枚举量是整型，可被提升为int类型，但int类型不能自动转换为枚举类型：
```
int color = blue;
band = 3;           //invalid
color = 3 + red;
```
3对应的枚举量是green，但将3赋给band将导致类型错误。不过将green赋给band是可以的，因为它们都是spectrum类型。表达式3 + red中的加法并非为枚举量定义，但red被转换为int类型，因此结果的类型也是int。由于在这种情况下，枚举将被转换为int，因此可以在算术表达式中同时使用枚举和常规整数，尽管并没有为枚举本身定义算术运算。
```
band = orange + red;    //not valid, but a little tricky
```
非法的原因有些复杂。确实没有为枚举定义运算符+，但用于算术表达式中时，枚举将被转换为整数，因此表达式orange + red将被转换为1 + 0。这是一个合法的表达式，但其类型为int，不能将其赋给类型为spectrum的变量band。如果int值是有效的，则可以通过强制类型转换，将它赋给枚举变量
```
band = spectrum(3);
```
如果试图对一个不适当的值进行强制类型转换，将出现什么情况呢？结果是不确定的，这意味着这样做不会出错，但不能依赖得到的结果：
枚举更常被用来定义相关的符号常量，而不是新类型。可以用枚举来定义switch语句中使用的符号常量,如果打算只使用常量，而不创建枚举类型的变量，则可以省略枚举类型的名称.
### 4.6.1 设置枚举量的值
可以使用赋值运算符来显式地设置枚举量的值：指定的值必须是整数。也可以只显式地定义其中一些枚举量的值：可以创建多个值相同的枚举量：
```
enum bits{one = 1, two = 2, four = 4, eight = 8};
enum bigstep{first, second = 100, third};
enum {zero, null  = 0, one, numero_uno = 1};
```
first在默认情况下为0。后面没有被初始化的枚举量的值将比其前面的枚举量大1。因此，third的值为101。zero和null都为0，one和umero_uno都为1。
### 4.6.2 枚举的取值范围
最初，对于枚举来说，只有声明中指出的那些值是有效的。然而，C++现在通过强制类型转换，增加了可赋给枚举变量的合法值。每个枚举都有取值范围（range），通过强制类型转换，可以将取值范围中的任何整数值赋给枚举变量，即使这个值不是枚举值。
```
enum bits{one = 1, two = 2, four = 4, eight = 8};
bits myflag;
myflag = bits(6);
```
其中6不是枚举值，但它位于枚举定义的取值范围内。
取值范围的定义如下。首先，要找出上限，需要知道枚举量的最大值。找到大于这个最大值的、最小的2的幂，将它减去1，得到的便是取值范围的上限。例如，前面定义的bigstep的最大值枚举值是101。在2的幂中，比这个数大的最小值为128，因此取值范围的上限为127。要计算下限，需要知道枚举量的最小值。如果它不小于0，则取值范围的下限为0；否则，采用与寻找上限方式相同的方式，但加上负号。例如，如果最小的枚举量为−6，而比它小的、最大的2的幂是−8（加上负号），因此下限为−7。
C++11扩展了枚举，增加了**作用域内枚举**（scoped enumeration），
## 4.7 指针和自由存储空间
计算机程序在存储数据时必须跟踪的三种属性
- 信息存储在何处
- 存储的值为多少
- 存储的信息是什么类型
**指针**是一个变量，其存储的是值的地址，而不是值本身。
只需对变量应用地址运算符（&），就可以获得它的位置。
使用常规变量时，值是指定的量，而地址为派生量。下面来看看指针策略，它是C++内存管理编程理念的核心。

处理存储数据的新策略刚好相反，将地址视为指定的量，而将值视为派生量。一种特殊类型的变量—指针用于存储值的地址。因此，指针名表示的是地址。*运算符被称为间接值（indirect velue）或解除引用（dereferencing）运算符，将其应用于指针，可以得到该地址处存储的值。
```
#include <iostream>
int main()
{
    using namespace std;
    int updates = 6;
    int * p_updates;

    p_updates = &updates;
     cout << updates;
     cout << p_updates;

     *p_updates = *p_updates + 1;
     cout << updates;
     return 0;
}
```
int变量updates和指针变量p_updates只不过是同一枚硬币的两面。变量updates表示值，并使用&运算符来获得地址；而变量p_updates表示地址，并使用*运算符来获得值.。由于p_updates指向updates，因此*p_updates和updates完全等价。可以像使用int变量那样使用*p_updates。

### 4.7.1 声明和初始化指针
指针声明必须指定指针指向的数据的类型。
p_updates是指针（地址），而*p_updates是int，而不是指针。
```
int* p1,p2;
```
声明创建一个指针和一个int变量。对每个指针变量名，都需要使用一个*。

可以在声明语句中初始化指针。
```
int higgens = 5;
int *pt = &higgen;
```
### 4.7.2 指针的危险
在C++中创建指针时，计算机将分配用来存储地址的内存，但不会分配用来存储指针所指向的数据的内存。为数据提供空间是一个独立的步骤，忽略这一步无疑是自找麻烦
```
long *fellow;
*fellow = 223323;
```
上述代码没有将地址赋给fellow。由于fellow没有被初始化，它可能有任何值。不管值是什么，程序都将它解释为存储223323的地址。如果fellow的值碰巧为1200，计算机将把数据放在地址1200上，即使这恰巧是程序代码的地址。fellow指向的地方很可能并不是所要存储223323的地方。这种错误可能会导致一些最隐匿、最难以跟踪的bug。

一定要在对指针应用解除引用运算符（*）之前，将指针初始化为一个确定的、适当的地址。这是关于使用指针的金科玉律。
### 4.7.3 指针和数字
指针不是整型。不能简单地将整数赋给指针。

要将数字值作为地址来使用，应通过强制类型转换将数字转换为适当的地址类型。
### 4.7.4 使用new来分配内存
前面我们都将指针初始化为变量的地址；变量是在编译时分配的有名称的内存，而指针只是为可以通过名称直接访问的内存提供了一个别名。指针真正的用武之地在于，在运行阶段分配**未命名的内存以存储值**。在这种情况下，只能通过指针来访问内存。在C语言中，可以用库函数malloc( )来分配内存；在C++中仍然可以这样做，但C++还有更好的方法—new运算符。

在运行阶段为一个int值分配未命名的内存，并使用指针来访问这个值。这里的关键所在是C++的new运算符。程序员要告诉new，需要为哪种数据类型分配内存；new将找到一个长度正确的内存块，并返回该内存块的地址。程序员的责任是将该地址赋给一个指针。
```
int *pn = new int;
```
new int告诉程序，需要适合存储int的内存。new运算符根据类型来确定需要多少字节的内存。然后，它找到这样的内存，并返回其地址。接下来，将地址赋给pn，pn是被声明为指向int的指针。现在，pn是地址，而*pn是存储在那里的值。

我们说pn指向一个数据对象，这里的“对象”不是“面向对象编程”中的对象，而是一样“东西”。术语“数据对象”比“变量”更通用，它指的是为数据项分配的内存块。因此，变量也是数据对象，但pn指向的内存不是变量。乍一看，处理数据对象的指针方法可能不太好用，但它使程序在管理内存方面有更大的控制权。为一个数据对象（可以是结构，也可以是基本类型）获得并指定分配内存的通用格式如下：
```
typeName *pointer_name = new typeName;
```
需要在两个地方指定数据类型：用来指定需要什么样的内存和用来声明合适的指针。

new分配的内存块通常与常规变量声明分配的内存块不同。变量nights和pd的值都存储在被称为栈（stack）的内存区域中，而new从被称为堆（heap）或自由存储区（freestore）的内存区域分配内存。
### 4.7.5 使用delete释放内存
归还或释放（free）的内存可供程序的其他部分使用。使用delete时，后面要加上指向内存块的指针。
```
int *ps = new int;
...
delete ps;
```
这将释放ps指向的内存，但不会删除指针ps本身。一定要配对地使用new和delete；否则将发生内存泄漏（memory leak），也就是说，被分配的内存再也无法使用了。

不要尝试释放已经释放的内存块，C++标准指出，这样做的结果将是不确定的，这意味着什么情况都可能发生。另外，不能使用delete来释放声明变量所获得的内存：只能用delete来释放使用new分配的内存。然而，对空指针使用delete是安全的。

一般来说，不要创建两个指向同一个内存块的指针，因为这将增加错误地删除同一个内存块两次的可能性。但稍后您会看到，对于返回指针的函数，使用另一个指针确实有道理。
### 4.7.6 使用new来创建动态数组
对于大型数据（如数组、字符串和结构），应使用new，这正是new的用武之地。
在编译时给数组分配内存被称为**静态联编（static binding）**，意味着数组是在编译时加入到程序中的。但使用new时，如果在运行阶段需要数组，则创建它；如果不需要，则不创建。还可以在程序运行时选择数组的长度。这被称为**动态联编（dynamic binding）**，意味着数组是在程序运行时创建的。使用静态联编时，必须在编写程序时指定数组的长度；使用动态联编时，程序将在运行时确定数组的长度。
#### 1.使用new创建动态数组
只要将数组的元素类型和元素数目告诉new即可。必须在类型名后加上方括号，其中包含元素数目。
```
int *psome = new int[10];
```
new运算符返回第一个元素的地址。在这个例子中，该地址被赋给指针psome。
当程序使用完new分配的内存块时，应使用delete释放它们。
```
delete []psome;
```
方括号告诉程序，应释放整个数组，而不仅仅是指针指向的元素。请注意delete和指针之间的方括号。

使用new和delete时，应遵守以下规则。
- 不要使用delete来释放不是new分配的内存。
- 不要使用delete释放同一个内存块两次。
- 如果使用new [ ]为数组分配内存，则应使用delete [ ]来释放。
- 如果使用new [ ]为一个实体分配内存，则应使用delete（没有方括号）来释放。
- 对空指针应用delete是安全的。
psome是指向一个int（数组第一个元素）的指针。您的责任是跟踪内存块中的元素个数。
实际上，程序确实跟踪了分配的内存量，以便以后使用delete [ ]运算符时能够正确地释放这些内存。不能使用sizeof运算符来确定动态分配的数组包含的字节数。
为数组分配内存的通用格式如下：
```
type_name *pointer_name = new type_name[num_elements];
```
使用new运算符可以确保内存块足以存储num_elements个类型为type_name的元素，而pointer_name将指向第1个元素。下面将会看到，可以以使用数组名的方式来使用pointer_name。
#### 2.使用动态数组
可以将它看作是一根指向该元素的手指。假设int占4个字节，则将手指沿正确的方向移动4个字节，手指将指向第2个元素。总共有10个元素，这就是手指的移动范围。因此，new语句提供了识别内存块中每个元素所需的全部信息。

只要把指针当作数组名使用即可。也就是说，对于第1个元素，可以使用psome[0]，而不是*psome；对于第2个元素，可以使用psome[1]，依此类推。C和C++内部都使用指针来处理数组。数组和指针基本等价是C和C++的优点之一。

不能修改数组名的值。但指针是变量，因此可以修改它的值。请注意将p3加1的效果。表达式p3[0]现在指的是数组的第2个值。因此，将p3加1导致它指向第2个元素而不是第1个。将它减1后，指针将指向原来的值，这样程序便可以给delete[ ]提供正确的地址。
## 4.8 指针、数组和指针算术
指针和数组基本等价的原因在于指针算术（pointer arithmetic）和C++内部处理数组的方式。将指针变量加1后，增加的量等于它指向的类型的字节数。C++将数组名解释为地址。
在多数情况下，C++将数组名解释为数组第1个元素的地址。

现在来看一看数组表达式stacks[1]。C++编译器将该表达式看作是*（stacks + 1），这意味着先计算数组第2个元素的地址，然后找到存储在那里的值。最后的结果便是stacks [1]的含义。运算符优先级要求使用括号，如果不使用括号，将给*stacks加1，而不是给stacks加1。通常，使用数组表示法时，C++都执行下面的转换：
```
arrayname[i] becomes *(arrayname + i)
```
如果使用的是指针，而不是数组名，则C++也将执行同样的转换：
```
pointername[i] becomes *(pointername + i)
```
在很多情况下，可以相同的方式使用指针名和数组名。对于它们，可以使用数组方括号表示法，也可以使用解除引用运算符（*）。在多数表达式中，它们都表示地址。区别之一是，可以修改指针的值，而数组名是常量。
另一个区别是，对数组应用sizeof运算符得到的是数组的长度，而对指针应用sizeof得到的是指针的长度，即使指针指向的是一个数组。

数组名被解释为其第一个元素的地址，而对数组名应用地址运算符时，得到的是整个数组的地址：
```
short tell[10];

short (*pas)[20] = &tell;
```
从数字上说，这两个地址相同；但从概念上说，&tell[0]（即tell）是一个2字节内存块的地址，而&tell是一个20字节内存块的地址。表达式tell + 1将地址值加2，而表达式&tell + 2将地址加20。

如果省略括号，优先级规则将使得pas先与[20]结合，导致pas是一个short指针数组，它包含20个元素，因此括号是必不可少的。其次，如果要描述变量的类型，可将声明中的变量名删除。因此，pas的类型为short (*) [20]。另外，由于pas被设置为&tell，因此*pas与tell等价，所以(*pas) [0]为tell数组的第一个元素。
### 4.8.2 指针小结
1. 声明指针
```
typeName *pointerName;
```
2. 给指针赋值
应将内存地址赋给指针。可以对变量名应用&运算符，来获得被命名的内存的地址，new运算符返回未命名的内存的地址。
3. 对指针解除引用
对指针解除引用意味着获得指针指向的值。对指针应用解除引用或间接值运算符（*）来解除引用。
另一种对指针解除引用的方法是使用数组表示法，例如，pn[0]与*pn是一样的。决不要对未被初始化为适当地址的指针解除引用。
4. 区分指针和指针所指向的值
如果pt是指向int的指针，则*pt不是指向int的指针，而是完全等同于一个int类型的变量。pt才是指针。
5. 数组名
在多数情况下，C++将数组名视为数组的第一个元素的地址。一种例外情况是，将sizeof运算符用于数组名用时，此时将返回整个数组的长度（单位为字节）。
6. 指针算术
C++允许将指针和整数相加。加1的结果等于原来的地址值加上指向的对象占用的总字节数。还可以将一个指针减去另一个指针，获得两个指针的差。后一种运算将得到一个整数，仅当两个指针指向同一个数组（也可以指向超出结尾的一个位置）时，这种运算才有意义；这将得到两个元素的间隔。
7. 数组的动态联编和静态联编
使用数组声明来创建数组时，将采用静态联编，即数组的长度在编译时设置：

使用new[ ]运算符创建数组时，将采用动态联编（动态数组），即将在运行时为数组分配空间，其长度也将在运行时设置。使用完这种数组后，应使用delete [ ]释放其占用的内存：

8. 数组表示法和指针表示法
使用方括号数组表示法等同于对指针解除引用：数组名和指针变量都是如此，因此对于指针和数组名，既可以使用指针表示法，也可以使用数组表示法。
### 4.8.3 指针和字符串
数组名是第一个元素的地址，如果给cout提供一个字符的地址，则它将从该字符开始打印，直到遇到空字符为止。这里的关键不在于flower是数组名，而在于flower是一个char的地址。这意味着可以将指向char的指针变量作为cout的参数，因为它也是char的地址。

这个用引号括起的字符串也应当是一个地址。这意味着对于数组中的字符串、用引号括起的字符串常量以及指针所描述的字符串，处理的方式是一样的，都将传递它们的地址。
```
const char * bird = "wren"
```
“wren”实际表示的是字符串的地址，因此这条语句将“wren”的地址赋给了bird指针。（一般来说，编译器在内存留出一些空间，以存储程序源代码中所有用引号括起的字符串，并将每个被存储的字符串与其地址关联起来。）这意味着可以像使用字符串“wren”那样使用指针bird，如下面的示例所示：
```
cout << "A concerned "<< bird <<" speaks\n"
```
字符串字面值是常量，这就是为什么代码在声明中使用关键字const的原因。以这种方式使用const意味着可以用bird来访问字符串，但不能修改它。

对于cout来说，使用数组名animal和指针bird是一样的。毕竟，它们都是字符串的地址，cout将显示存储在这两个地址上的两个字符串（“bear”和“wren”）。
对于输入，情况有点不同。只要输入比较短，能够被存储在数组中，则使用数组animal进行输入将是安全的。然而，使用bird来进行输入并不合适：
- 有些编译器将字符串字面值视为只读常量，如果试图修改它们，将导致运行阶段错误。在C++中，字符串字面值都将被视为常量，但并不是所有的编译器都对以前的行为做了这样的修改。
- 有些编译器只使用字符串字面值的一个副本来表示程序中所有的该字面值。

C++不能保证字符串字面值被唯一地存储。也就是说，如果在程序中多次使用了字符串字面值“wren”，则编译器将可能存储该字符串的多个副本，也可能只存储一个副本。如果是后面一种情况，则将bird设置为指向一个“wren”，将使它只是指向该字符串的唯一一个副本。将值读入一个字符串可能会影响被认为是独立的、位于其他地方的字符串。无论如何，由于bird指针被声明为const，因此编译器将禁止改变bird指向的位置中的内容。

—只要使用足够大的char数组来接收输入即可。请不要使用字符串常量或未被初始化的指针来接收输入。为避免这些问题，也可以使用std::string对象，而不是数组。

如果给cout提供一个指针，它将打印地址。但如果指针的类型为char *，则cout将显示指向的字符串。如果要显示的是字符串的地址，则必须将这种指针强制转换为另一种指针类型，如int *。

要获得字符串的副本，还需要做其他工作。首先，需要分配内存来存储该字符串，这可以通过声明另一个数组或使用new来完成。后一种方法使得能够根据字符串的长度来指定所需的空间：
```
ps = new char[strlen(animal) + 1];
```
接下来，需要将animal数组中的字符串复制到新分配的空间中。将animal赋给ps是不可行的，因为这样只能修改存储在ps中的地址，从而失去程序访问新分配内存的唯一途径。需要使用库函数strcpy( )：
```
strcpy(ps, animal);
```
strcpy( )函数接受2个参数。第一个是目标地址，第二个是要复制的字符串的地址。

初始化数组时，请使用=运算符；否则应使用strcpy( )或strncpy( )。用strncpy( )该函数还接受第3个参数—要复制的最大字符数。如果该函数在到达字符串结尾之前，目标内存已经用完，则它将不会添加空字符。应该将最后一个元素设置成空字符。
### 4.8.4 使用new创建动态结构
由于类与结构非常相似，因此本节介绍的有关结构的技术也适用于类。
将new用于结构由两步组成：创建结构和访问其成员。要创建结构，需要同时使用结构类型和new。例如，要创建一个未命名的inflatable类型，并将其地址赋给一个指针，可以这样做：
```
inflatable *ps = new inflatable;
```
这将把足以存储inflatable结构的一块可用内存的地址赋给ps。这种句法和C++的内置类型完全相同。
创建动态结构时，不能将成员运算符句点用于结构名，因为这种结构没有名称，只是知道它的地址。C++专门为这种情况提供了一个运算符：箭头成员运算符（−>）。该运算符由连字符和大于号组成，可用于指向结构的指针，就像点运算符可用于结构名一样。例如，如果ps指向一个inflatable结构，则ps−>price是被指向的结构的price成员

如果结构标识符是结构名，则使用句点运算符；如果标识符是指向结构的指针，则使用箭头运算符。

另一种访问结构成员的方法是，如果ps是指向结构的指针，则* ps就是被指向的值—结构本身。由于*ps是一个结构，因此（ *ps）.price是该结构的price成员。C++的运算符优先规则要求使用括号。
#### 1.一个使用new和delete的示例
下面介绍一个使用new和delete来存储通过键盘输入的字符串的示例。程序定义了一个函数getname( )，该函数返回一个指向输入字符串的指针。该函数将输入读入到一个大型的临时数组中，然后使用new [ ]创建一个刚好能够存储该输入字符串的内存块，并返回一个指向该内存块的指针。对于读取大量字符串的程序，这种方法可以节省大量内存（实际编写程序时，使用string类将更容易，因为这样可以使用内置的new和delete）。
```
#include <iostream>
#include <cstring>
using namespace std;
char * getname(void);

int main()

{
    char *name;
    
    name = getname();
    cout << name << " at " << (int *) name << "\n";
    delete [] name;

    name = getname();
    cout << name << " at " << (int *) name << "\n";
    delete [] name;
    return 0;
}

char * getname()
{
    char temp[80];
    cout << "Enter last name:";
    cin >> temp;
    char *pn = new char[strlen(temp)+1];
    strcpy(pn, temp);

    return pn;
}
```
#### 2.程序说明
它使用cin将输入的单词放到temp数组中，然后使用new分配新内存，以存储该单词。getname( )使用标准库函数strcpy( )将temp中的字符串复制到新的内存块中。该函数并不检查内存块是否能够容纳字符串，但getname( )通过使用new请求合适的字节数来完成了这样的工作。最后，函数返回pn，这是字符串副本的地址。

getname( )分配内存，而main( )释放内存。把new和delete分开放置了,这样做也是可以的。
### 4.8.5 自动存储、静态存储和动态存储
C++有3种管理数据内存的方式：自动存储、静态存储和动态存储（有时也叫作自由存储空间或堆）。（C++11新增了第四种类型—线程存储）
#### 1.自动存储
在函数内部定义的常规变量使用自动存储空间，被称为**自动变量（automatic variable）**，这意味着它们在所属的函数被调用时自动产生，在该函数结束时消亡。
例如，程序清单4.22中的temp数组仅当getname( )函数活动时存在。当程序控制权回到main( )时，temp使用的内存将自动被释放。如果getname( )返回temp的地址，则main( )中的name指针指向的内存将很快得到重新使用。这就是在getname( )中使用new的原因之一。

实际上，自动变量是一个局部变量，其作用域为包含它的代码块。代码块是被包含在花括号中的一段代码。

自动变量通常存储在栈中。这意味着执行代码块时，其中的变量将依次加入到栈中，而在离开代码块时，将按相反的顺序释放这些变量，这被称为后进先出（LIFO）。因此，在程序执行过程中，栈将不断地增大和缩小。

#### 2.静态存储
静态存储是整个程序执行期间都存在的存储方式。使变量成为静态的方式有两种：一种是在函数外面定义它；另一种是在声明变量时使用关键字static：
```
static double fee = 56.50;
```
在K&R C中，只能初始化静态数组和静态结构，而C++ Release2.0（及后续版本）和ANSI C中，也可以初始化自动数组和自动结构。然而，一些您可能已经发现，有些C++实现还不支持对自动数组和自动结构的初始化。

自动存储和静态存储的关键在于：这些方法严格地限制了变量的寿命。变量可能存在于程序的整个生命周期（静态变量），也可能只是在特定函数被执行时存在（自动变量）。
#### 3.动态存储
new和delete运算符提供了一种比自动变量和静态变量更灵活的方法。它们管理了一个内存池，这在C++中被称为自由存储空间（freestore）或堆（heap）。该内存池同用于静态变量和自动变量的内存是分开的。
new和delete让您能够在一个函数中分配内存，而在另一个函数中释放它。因此，数据的生命周期不完全受程序或函数的生存时间控制。

在栈中，自动添加和删除机制使得占用的内存总是连续的，但new和delete的相互影响可能导致占用的自由存储区不连续，这使得跟踪新分配内存的位置更困难。
## 4.9 类型组合
```
struct antarctica_years_end
{
    int year;
};
antarctica_years_end s01, s02, s03;     //s01,s02,s03 are structures
s01.year = 1998;                        //使用成员运算符访问
antarctica_years_end * pa = &s02;       //创建指向这种结构的指针
pa -> year = 1999;                      //可使用间接成员运算符来访问成员
antarctica_years_end trio[3];           //可创建结构数组
trio[0].year = 2003;                    //可以使用成员运算符访问元素的成员
/*其中trio是一个数组，trio[0]是一个结构，而trio[0].year是该结构的一个成员。由于数组名是一个指针，因此也可使用间接成员运算符*/
(trio+1)->year = 2004;                  //same as trio[1].year = 2004;
const antarctica_years_end *arp[3] = {&s01, &s02, &s03}; //可创建指针数组
cout << arp[1]->year;                   //arp[1]就是一个指针，可将间接成员运算符应用于它，以访问成员
const antarctica_years_end ** ppa = arp;//其中arp是一个数组的名称，因此它是第一个元素的地址。但其第一个元素为指针，因此ppa是一个指针，指向一个指向constantarctica_years_end的指针。
auto ppb = arp;                         //C++11版本的auto提供的方便。
/* 由于ppa是一个指向结构指针的指针，因此*ppa是一个结构指针，可将间接成员运算符应用于它：*/
cout << (*ppa)->year;
cout << (*(ppa+1))->year;
```
由于ppa指向arp的第一个元素，因此* ppa为第一个元素，即&s01。所以，(*ppa)->year为s01的year成员。在第二条语句中，ppb+1指向下一个元素arp[1]，即&s02。其中的括号必不可少，这样才能正确地结合。
## 4.10 数组的替代品
模板类vector和array是数组的替代品。
### 4.10.1 模板类vector
模板类vector类似于string类，也是一种动态数组。基本上，它是使用new创建动态数组的替代品。实际上，vector类确实使用new和delete来管理内存，但这种工作是自动完成的。
首先，要使用vector对象，必须包含头文件vector。其次，vector包含在名称空间std中，因此您可使用using编译指令、using声明或std::vector。第三，模板使用不同的语法来指出它存储的数据类型。第四，vector类使用不同的语法来指定元素数。
```
#include <vector>
...
using namespace std;
vector<int> vi;
int n;
cin >> n;
vector<double> vd(n);
```
其中，vi是一个vector<int>对象，vd是一个vector<double>对象。由于vector对象在您插入或添加值时自动调整长度，因此可以将vi的初始长度设置为零。但要调整长度，需要使用vector包中的各种方法。
一般而言，下面的声明创建一个名为vt的vector对象，它可存储n_elem个类型为typeName的元素：
```
vector<typeName> vt(n_elem);
```
其中参数n_elem可以是整型常量，也可以是整型变量。
### 4.10.2 模板类array（C++11）
vector类的功能比数组强大，但付出的代价是效率稍低。C++11新增了模板类array，它也位于名称空间std中。与数组一样，array对象的长度也是固定的，也使用栈（静态内存分配），而不是自由存储区，因此其效率与数组相同，但更方便，更安全。要创建array对象，需要包含头文件array。array对象的创建语法与vector稍有不同：
```
#include <array>
...
using namespace std;
array<int, 5> ai;
array<double, 4> ad = {1.2,2.1,3.43,4.3};
```
下面的声明创建一个名为arr的array对象，它包含n_elem个类型为typename的元素：
```
array<typeName,n_elem> arr;
```
与创建vector对象不同的是，n_elem不能是变量。
### 4.10.3 比较数组、vector对象和array对象
首先，注意到无论是数组、vector对象还是array对象，都可使用标准数组表示法来访问各个元素。其次，从地址可知，array对象和数组存储在相同的内存区域（即栈）中，而vector对象存储在另一个区域（自由存储区或堆）中。第三，注意到可以将一个array对象赋给另一个array对象；而对于数组，必须逐元素复制数据。
```
a1[-2] = 20.2;
```
其含义如下：找到a1指向的地方，向前移两个double元素，并将20.2存储到目的地。vector和array对象能够禁止这种行为吗？如果您让它们禁止，它们就能禁止。也就是说，您仍可编写不安全的代码，

然而，您还有其他选择。一种选择是使用成员函数at()。就像可以使用cin对象的成员函数getline()一样，您也可以使用vector和array对象的成员函数at()：
```
a2.at(1) = 2.3;
```
中括号表示法和成员函数at()的差别在于，使用at()时，将在运行期间捕获非法索引，而程序默认将中断。这种额外检查的代价是运行时间更长，这就是C++让允许您使用任何一种表示法的原因所在。
## 4.11 总结
1. 数组、结构和指针是C++的3种复合类型。数组可以在一个数据对象中存储多个同种类型的值。通过使用索引或下标，可以访问数组中各个元素。
2. 结构可以将多个不同类型的值存储在同一个数据对象中，可以使用成员关系运算符（.）来访问其中的成员。使用结构的第一步是创建结构模板，它定义结构存储了哪些成员。模板的名称将成为新类型的标识符，然后就可以声明这种类型的结构变量。
3. 共用体可以存储一个值，但是这个值可以是不同的类型，成员名指出了使用的模式。
4. 指针是被设计用来存储地址的变量。我们说，指针指向它存储的地址。指针声明指出了指针指向的对象的类型。对指针应用解除引用运算符，将得到指针指向的位置中的值。
5. 字符串是以空字符为结尾的一系列字符。字符串可用引号括起的字符串常量表示，其中隐式包含了结尾的空字符。可以将字符串存储在char数组中，可以用被初始化为指向字符串的char指针表示字符串。函数strlen( )返回字符串的长度，其中不包括空字符。函数strcpy( )将字符串从一个位置复制到另一个位置。在使用这些函数时，应当包含头文件cstring或string.h。
6. 头文件string支持的C++ string类提供了另一种对用户更友好的字符串处理方法。具体地说，string对象将根据要存储的字符串自动调整其大小，用户可以使用赋值运算符来复制字符串。
7. new运算符允许在程序运行时为数据对象请求内存。该运算符返回获得内存的地址，可以将这个地址赋给一个指针，程序将只能使用该指针来访问这块内存。如果数据对象是简单变量，则可以使用解除引用运算符（*）来获得其值；如果数据对象是数组，则可以像使用数组名那样使用指针来访问元素；如果数据对象是结构，则可以用指针解除引用运算符（->）来访问其成员。
8. 指针和数组紧密相关。如果ar是数组名，则表达式ar[i]被解释为*（ar + i），其中数组名被解释为数组第一个元素的地址。这样，数组名的作用和指针相同。反过来，可以使用数组表示法，通过指针名来访问new分配的数组中的元素。
9. 运算符new和delete允许显式控制何时给数据对象分配内存，何时将内存归还给内存池。自动变量是在函数中声明的变量，而静态变量是在函数外部或者使用关键字static声明的变量，这两种变量都不太灵活。自动变量在程序执行到其所属的代码块（通常是函数定义）时产生，在离开该代码块时终止。静态变量在整个程序周期内都存在。
10. C++98新增的标准模板库（STL）提供了模板类vector，它是动态数组的替代品。C++11提供了模板类array，它是定长数组的替代品。