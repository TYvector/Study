# 第4章 复合类型
## 4.1 数组
数组（array）是一种数据格式，能够存储多个同类型的值。计算机在内存中依次存储数组的各个元素。
数组声明应指出以下三点：
- 存储在每个元素中的值的类型；
- 数组名；
- 数组中的元素数。
在C++中，可以通过修改简单变量的声明，添加中括号（其中包含元素数目）来完成数组声明。
通用格式如下：
```
typeName arrayName[arraySize];
```
表达式arraySize指定元素数目，它必须是整型常数（如10）或const值，也可以是常量表达式（如8 * sizeof（int）），即其中所有的值在编译时都是已知的。
可以单独访问数组元素。方法是使用下标或索引来对元素进行编号。C++数组从0开始编号.C++使用带索引的方括号表示法来指定数组元素。注意，最后一个元素的索引比数组长度**小1**
```
#include <iostream>
int main()
{
    using namespace std;
    int yams[3];
    yam[0] = 7;
    yam[1] = 8;
    yam[2] = 6;
    int yamcosts[3] = {20 , 30 , 5};

    return 0;
}
```
### 4.1.1 程序说明
C++允许在声明语句中初始化数组元素。只需提供一个用逗号分隔的值列表（初始化列表），并将它们用花括号括起即可。
sizeof运算符返回类型或数据对象的长度（单位为字节）。注意，如果将sizeof运算符用于数组名，得到的将是整个数组中的字节数。但如果将sizeof用于数组元素，则得到的将是元素的长度（单位为字节）。
### 4.1.2 数组的初始化规则
只有在定义数组时才能使用初始化，此后就不能使用了，也不能将一个数组赋给另一个数组：
```
int cards[4] = {3,6,8,10};   //okay
int hands[4];               //okay
hands[4] = {5,6,7,9};       //not allowed
hands = cards;              //not allowed
```
可以使用下标分别给数组中的元素赋值。
初始化数组时，提供的值可以少于数组的元素数目。
如果只对数组的一部分进行初始化，则编译器将把其他元素设置为0。因此，将数组中所有的元素都初始化为0非常简单—只要显式地将第一个元素初始化为0，然后让编译器将其他元素都初始化为0即可：
```
long totals[500] = {0};
```
如果初始化数组时方括号内（[ ]）为空，C++编译器将计算元素个数。
### 4.1.3 C++11数组初始化方法
初始化数组时，可省略等号（=）
可不在大括号内包含任何东西，这将把所有元素都设置为零
```
double earnings[4] {1.2e4,1.6e4,1.1e4,1.7e4};
unsigned int counts[10] = {};
float balances[100]{};
```
列表初始化禁止缩窄转换
C++标准模板库（STL）提供了一种数组替代品—模板类vector，而C++11新增了模板类array。
## 4.2 字符串
字符串是存储在内存的连续字节中的一系列字符。C++处理字符串的方式有两种。第一种来自C语言，常被称为**C-风格字符串**（C-stylestring）。
以空字符（null character）结尾，空字符被写作\0，其ASCII码为0，用来标记字符串的结尾。
空字符对C-风格字符串而言至关重要。
不应将不是字符串的字符数组当作字符串来处理。
只需使用一个用引号括起的字符串即可，这种字符串被称为**字符串常量**（string constant）或**字符串字面值**（string literal）
```
char bird[11] = "Mr.Cheeps";
char fish[] = "Bubbles";
```
用引号括起的字符串隐式地包括结尾的空字符,各种C++输入工具通过键盘输入，将字符串读入到char数组中时，将自动加上结尾的空字符
应确保数组足够大，能够存储字符串中所有字符—包括空字符。使用字符串常量初始化字符数组是这样的一种情况，即让编译器计算元素数目更为安全。C++对字符串长度没有限制。
但"S"不是字符常量，它表示的是两个字符（字符S和\0）组成的字符串。更糟糕的是，"S"实际上表示的是字符串所在的内存地址。因此下面的语句试图将一个内存地址赋给shirt_size：
```
char shirt_size = "S";
```
由于地址在C++中是一种独立的类型，因此C++编译器不允许这种不合理的做法
### 4.2.1 拼接字符串常量
C++允许拼接字符串字面值，即将两个用引号括起的字符串合并为一个。任何两个由空白（空格、制表符和换行符）分隔的字符串常量都将自动拼接成一个。
拼接时不会在被连接的字符串之间添加空格，第二个字符串的第一个字符将紧跟在第一个字符串的最后一个字符（不考虑\0）后面。第一个字符串中的\0字符将被第二个字符串的第一个字符取代。
### 4.2.2 在数组中使用字符串
最常用的方法有两种—将数组初始化为字符串常量、将键盘或文件输入读入到数组中。
strlen( )函数返回的是存储在数组中的字符串的长度，而不是数组本身的长度。数组的长度不能短于strlen（ ）+1。
### 4.2.3 字符串输入
cin是如何确定已完成字符串输入呢？由于不能通过键盘输入空字符，因此cin需要用别的方法来确定字符串的结尾位置。cin使用空白（空格、制表符和换行符）来确定字符串的结束位置，这意味着cin在获取字符数组输入时只读取一个单词。读取该单词后，cin将该字符串放到数组中，并自动在结尾添加空字符。
另一个问题是，输入字符串可能比目标数组长。
### 4.2.4 每次读取一行字符串输入
每次读取一个单词通常不是最好的选择。具体地说，需要采用面向行而不是面向单词的方法。istream中的类（如cin）提供了一些面向行的类成员函数：getline( )和get( )。这两个函数都读取一行输入，直到到达换行符。随后getline( )将丢弃换行符，而get( )将换行符保留在输入序列中。
#### 面向行的输入：getline( )
getline( )函数读取整行，它使用通过回车键输入的换行符来确定输入结尾。要调用这种方法，可以使用cin.getline( )。该函数有两个参数。第一个参数是用来存储输入行的数组的名称，第二个参数是要读取的字符数。如果这个参数为20，则函数最多读取19个字符，余下的空间用于存储自动在结尾处添加的空字符。getline( )成员函数在读取指定数目的字符或遇到换行符时停止读取。

`cin.getine(name,20);`

#### 面向行的输入：get( )
istream类有另一个名为get( )的成员函数，该函数有几种变体。其中一种变体的工作方式与getline( )类似，它们接受的参数相同，解释参数的方式也相同，并且都读取到行尾。但get并不再读取并丢弃换行符，而是将其留在输入队列中。假设我们连续两次调用get( )：
由于第一次调用后，换行符将留在输入队列中，因此第二次调用时看到的第一个字符便是换行符。因此get( )认为已到达行尾，而没有发现任何可读取的内容。如果不借助于帮助，get( )将不能跨过该换行符。
使用不带任何参数的cin.get( )调用可读取下一个字符（即使是换行符），因此可以用它来处理换行符，为读取下一行输入做好准备。
```
cin.get(name,ArSize);
cin.get();
cin.get(dessert,ArSize);
```
另一种使用get( )的方式是将两个类成员函数拼接起来（合并）
```
cin.get(name,ArSize).get();
```
是由于cin.get（name，ArSize）返回一个cin对象，该对象随后将被用来调用get( )函数。
同样，下面的语句将把输入中连续的两行分别读入到数组name1和name2 中，其效果与两次调用cin.getline( )相同：
```
cin.getline(name1,ArSize).getline(name2,ArSize);
```
C++允许函数有多个版本，条件是这些版本的参数列表不同。
getline( )使用起来简单一些，但get( )使得检查错误更简单些。
#### 空行和其他问题
当get( )（不是getline( )）读取空行后将设置失效位（failbit）。这意味着接下来的输入将被阻断，但可以用下面的命令来恢复输入：
```
cin.clear();
```
如果输入行包含的字符数比指定的多，则getline( )和get( )将把余下的字符留在输入队列中，而getline( )还会设置失效位，并关闭后面的输入。
### 4.2.5 混合输入字符串和数字
当cin读取年份，将回车键生成的换行符留在了输入队列中。后面的cin.getline( )看到换行符后，将认为是一个空行，并将一个空字符串赋给address数组。解决之道是，在读取地址之前先读取并丢弃换行符。这可以通过几种方法来完成，其中包括使用没有参数的get( )和使用接受一个char参数的get( )，可以单独进行调用：
```
cin >> year;
cin.get(); // or cin.get(ch);
```
也可以利用表达式cin>>year返回cin对象，将调用拼接起来：
```
(cin >> year).get(); //or (cin>>year).get(ch);
```
C++程序常使用指针（而不是数组）来处理字符串。
## 4.3 string类简介
要使用string类，必须在程序中包含头文件string。string类位于名称空间std中，因此您必须提供一条using编译指令，或者使用std::string来引用它。string类定义隐藏了字符串的数组性质，让您能够像处理普通变量那样处理字符串。
在很多方面，使用string对象的方式与使用字符数组相同。
- 可以使用C-风格字符串来初始化string对象。
- 可以使用cin来将键盘输入存储到string对象中。
- 可以使用cout来显示string对象。
- 可以使用数组表示法来访问存储在string对象中的字符。
可以将string对象声明为简单变量，而不是数组
### 4.3.1 C++11字符串初始化
C++11也允许将列表初始化用于C-风格字符串和string对象
### 4.3.2 赋值、拼接和附加
不能将一个数组赋给另一个数组，但可以将一个string对象赋给另一个string对象：
string类简化了字符串合并操作。可以使用运算符+将两个string对象合并起来，还可以使用运算符+=将字符串附加到string对象的末尾。
### 4.3.3 string类的其他操作
头文件cstring（以前为string.h）提供了这些函数。可以使用
函数strcpy( )将字符串复制到字符数组中，使用函数strcat( )将字符串附加到字符数组末尾：
string类具有自动调整大小的功能。C函数库确实提供了与strcat( )和strcpy( )类似的函数—strncat( )和strncpy( )，它们接受指出目标数组最大允许长度的第三个参数
下面是两种确定字符串中字符数的方法：
```
int len1 = str1.size();
int len2 = strlen(charr1);
```
### 4.3.4 string类I/O
未初始化的数组的内容是未定义的；函数strlen( )从数组的第一个元素开始计算字节数，直到遇到空字符。
未被初始化的string对象的长度被自动设置为0。
下面是将一行输入读取到string对象中的代码
```
getline(cin,str);
```
### 4.3.5 其他形式的字符串字面值
除char类型外，C++还有类型wchar_t；而C++11新增了类型char16_t和char32_t。可创建这些类型的数组和这些类型的字符串字面值。C++分别使用前缀L、u和U表示，
C++使用前缀u8来表示UTF-8。
C++11新增的另一种类型是原始（raw）字符串。在原始字符串中，字符表示的就是自己，例如，序列\n不表示换行符，而表示两个常规字符—斜杠和n
原始字符串将"(和)"用作定界符，并使用前缀R来标识原始字符串：
原始字符串语法允许您在表示字符串开头的"和(之间添加其他字符，这意味着表示字符串结尾的"和)之间也必须包含这些字符。
自定义定界符时，在默认定界符之间添加任意数量的基本字符，但空格、左括号、右括号、斜杠和控制字符（如制表符和换行符）除外。
可将前缀R与其他字符串前缀结合使用
## 4.4 结构简介
结构是一种比数组更灵活的数据格式，因为同一个结构可以存储多种类型的数据
结构也是C++ OOP堡垒（类）的基石。
结构是用户定义的类型，而结构声明定义了这种类型的数据属性。定义了类型后，便可以创建这种类型的变量。因此创建结构包括两步。首先，**定义结构描述**—它描述并标记了能够存储在结构中的各种数据类型。然后按描述**创建结构变量**（结构数据对象）。
```
struct inflatable
{
    char name[20];
    float volume;
    double price;
}
```
关键字struct表明，这些代码定义的是一个结构的布局。标识符inflatable是这种数据格式的名称.这样，便可以像创建char或int类型的变量那样创建inflatable类型的变量了。接下来的大括号中包含的是结构存储的数据类型的列表，其中每个列表项都是一条声明语句。列表中的每一项都被称为结构成员，因此infatable结构有3个成员
定义结构后，便可以创建这种类型的变量了：
C++允许在声明结构变量时省略关键字struct,在C++中，结构标记的用法与基本类型名相同。
通过成员名能够访问结构的成员，就像通过索引能够访问数组的元素一样。
### 4.4.1 在程序中使用结构
```
#include <iostream>
struct inflatable
{
    char name[20];
    float volume;
    double price;
};

int main()
{
    using namespace std;
    inflatable guest =
    {
        "Glorious Gloria",
        1.88,
        2.99
    };

    inflatable pal = 
    {
        "Audacious Arthur",
        3.12,
        32.99
    };

    cout << guest.name << endl;
    cout << guest.price + pal.price << endl;

    return 0;
}
```
结构声明的位置很重要。有两种选择。可以将声明放在main( )函数中，紧跟在开始括号的后面。另一种选择是将声明放到main( )的前面，这里采用的便是这种方式，位于函数外面的声明被称为外部声明。外部声明可以被其后面的任何函数使用，而内部声明只能被该声明所属的函数使用。

变量也可以在函数内部和外部定义，外部变量由所有的函数共享.

和数组一样，使用由逗号分隔值列表，并将这些值用花括号括起。可将每个结构成员看作是相应类型的变量。
### 4.4.2 C++11结构初始化
与数组一样，C++11也支持将列表初始化用于结构，且等号（=）是可选的：
如果大括号内未包含任何东西，各个成员都将被设置为零。
最后，不允许缩窄转换。
### 4.4.3 结构可以将string类作为成员吗
答案是肯定的

一定要让结构定义能够访问名称空间std。为此，可以将编译指令using移到结构定义之前；也可以将name的类型声明为std::string。
### 4.4.4 其他结构属性
C++使用户定义的类型与内置类型尽可能相似。可以将结构作为参数传递给函数，也可以让函数返回一个结构。另外，还可以使用赋值运算符（=）将结构赋给另一个同类型的结构，这样结构中每个成员都将被设置为另一个结构中相应成员的值，即使成员是数组。这种赋值被称为**成员赋值**（memberwise assignment）

可以同时完成定义结构和创建结构变量的工作。为此，只需将变量名放在结束括号的后面即可：甚至可以初始化以这种方式创建的变量：

还可以声明没有名称的结构类型，方法是省略名称，同时定义一种结构类型和一个这种类型的变量
```
struct
{
    int x;
    int y;
} position;
```
### 4.4.5 结构数组
也可以创建元素为结构的数组，方法和创建基本类型数组完全相同。
```
inflatable gifts[100];
```
要初始化结构数组，可以结合使用初始化数组的规则（用逗号分隔每个元素的值，并将这些值用花括号括起）和初始化结构的规则（用逗号分隔每个成员的值，并将这些值用花括号括起）。最终结果为一个被括在花括号中、用逗号分隔的值列表，其中每个值本身又是一个被括在花括号中、用逗号分隔的值列表：
```
inflatable guest[2] = 
{
    {"Bambi",0.5,21.99},
    {"Godzilla",2000,565.99}
}
```
### 4.4.6 结构中的位字段
C++也允许指定占用特定位数的结构成员,字段的类型应为整型或枚举（稍后将介绍），接下来是冒号，冒号后面是一个数字，它指定了使用的位数。
```
struct torgle_register
{
    unsigned int SN : 4;
    unsigned int : 4;
    bool goodIn : 1;
    bool goodTorgle : 1;
}
```
## 4.5 共用体
共用体（union）是一种数据格式，它能够存储不同的数据类型，但只能同时存储其中的一种类型。也就是说，结构可以同时存储int、long和double，共用体只能存储int、long或double。共用体的句法与结构相似，但含义不同。
```
union one4all
{
    int int_val;
    long long_val;
    double double_val;
}
```
成员名称标识了变量的容量。由于共用体每次只能存储一个值，因此它必须有足够的空间来存储最大的成员，所以，共用体的长度为其最大成员的长度。
共用体的用途之一是，当数据项使用两种或更多种格式（但不会同时使用）时，可节省空间.
```
struct widget
{
    char brand[20];
    int type;
    union id
    {
        long id_num;
        char id_char[20];
    } id_val;
};
···
widget prize;
···
if (prize.type == 1)
    cin >> prize.id_val.id_num;
else
    cin >> prize.id_val.id_char;

```

匿名共用体（anonymous union）没有名称，其成员将成为位于相同地址处的变量。显然，每次只有一个成员是当前的成员：
```
struct widget
{
    char brand[20];
    int type;
    union
    {
        long id_num;
        char id_char[20];
    };
};
```
由于共用体是匿名的，因此id_num和id_char被视为prize的两个成员，它们的地址相同，所以不需要中间标识符id_val。
共用体常用于（但并非只能用于）节省内存。
## 4.6 枚举
C++的enum工具提供了另一种创建符号常量的方式，这种方式可以代替const。它还允许定义新类型，但必须按严格的限制进行。使用enum的句法与使用结构相似。
```
enum spectrum {red, orange, yellow, green, blue, violet, indigo, ultraviolet};
```
这条语句完成两项工作。
- 让spectrum成为新类型的名称；spectrum被称为**枚举**（enumeration），就像struct变量被称为结构一样。
- 将red、orange、yellow等作为符号常量，它们对应整数值0～7。这些常量叫作**枚举量**（enumerator）。
在默认情况下，将整数值赋给枚举量，第一个枚举量的值为0，第二个枚举量的值为1，依次类推。可以通过显式地指定整数值来覆盖默认值，可以用枚举名来声明这种类型的变量：
```
spectrum band;
```
在不进行强制类型转换的情况下，只能将定义枚举时使用的枚举量赋给这种枚举的变量，因此，spectrum变量受到限制，只有8个可能的值。对于枚举，只定义了赋值运算符。具体地说，没有为枚举定义算术运算
```
band = blue;
band = orange;
```
枚举量是整型，可被提升为int类型，但int类型不能自动转换为枚举类型：
```
int color = blue;
band = 3;           //invalid
color = 3 + red;
```
3对应的枚举量是green，但将3赋给band将导致类型错误。不过将green赋给band是可以的，因为它们都是spectrum类型。表达式3 + red中的加法并非为枚举量定义，但red被转换为int类型，因此结果的类型也是int。由于在这种情况下，枚举将被转换为int，因此可以在算术表达式中同时使用枚举和常规整数，尽管并没有为枚举本身定义算术运算。
```
band = orange + red;    //not valid, but a little tricky
```
非法的原因有些复杂。确实没有为枚举定义运算符+，但用于算术表达式中时，枚举将被转换为整数，因此表达式orange + red将被转换为1 + 0。这是一个合法的表达式，但其类型为int，不能将其赋给类型为spectrum的变量band。如果int值是有效的，则可以通过强制类型转换，将它赋给枚举变量
```
band = spectrum(3);
```
如果试图对一个不适当的值进行强制类型转换，将出现什么情况呢？结果是不确定的，这意味着这样做不会出错，但不能依赖得到的结果：
枚举更常被用来定义相关的符号常量，而不是新类型。可以用枚举来定义switch语句中使用的符号常量,如果打算只使用常量，而不创建枚举类型的变量，则可以省略枚举类型的名称.
### 4.6.1 设置枚举量的值
可以使用赋值运算符来显式地设置枚举量的值：指定的值必须是整数。也可以只显式地定义其中一些枚举量的值：可以创建多个值相同的枚举量：
```
enum bits{one = 1, two = 2, four = 4, eight = 8};
enum bigstep{first, second = 100, third};
enum {zero, null  = 0, one, numero_uno = 1};
```
first在默认情况下为0。后面没有被初始化的枚举量的值将比其前面的枚举量大1。因此，third的值为101。zero和null都为0，one和umero_uno都为1。
### 4.6.2 枚举的取值范围
最初，对于枚举来说，只有声明中指出的那些值是有效的。然而，C++现在通过强制类型转换，增加了可赋给枚举变量的合法值。每个枚举都有取值范围（range），通过强制类型转换，可以将取值范围中的任何整数值赋给枚举变量，即使这个值不是枚举值。
```
enum bits{one = 1, two = 2, four = 4, eight = 8};
bits myflag;
myflag = bits(6);
```
其中6不是枚举值，但它位于枚举定义的取值范围内。
取值范围的定义如下。首先，要找出上限，需要知道枚举量的最大值。找到大于这个最大值的、最小的2的幂，将它减去1，得到的便是取值范围的上限。例如，前面定义的bigstep的最大值枚举值是101。在2的幂中，比这个数大的最小值为128，因此取值范围的上限为127。要计算下限，需要知道枚举量的最小值。如果它不小于0，则取值范围的下限为0；否则，采用与寻找上限方式相同的方式，但加上负号。例如，如果最小的枚举量为−6，而比它小的、最大的2的幂是−8（加上负号），因此下限为−7。
C++11扩展了枚举，增加了**作用域内枚举**（scoped enumeration），
## 4.7 指针和自由存储空间
计算机程序在存储数据时必须跟踪的三种属性
- 信息存储在何处
- 存储的值为多少
- 存储的信息是什么类型
**指针**是一个变量，其存储的是值的地址，而不是值本身。
只需对变量应用地址运算符（&），就可以获得它的位置。
使用常规变量时，值是指定的量，而地址为派生量。下面来看看指针策略，它是C++内存管理编程理念的核心。

处理存储数据的新策略刚好相反，将地址视为指定的量，而将值视为派生量。一种特殊类型的变量—指针用于存储值的地址。因此，指针名表示的是地址。*运算符被称为间接值（indirect velue）或解除引用（dereferencing）运算符，将其应用于指针，可以得到该地址处存储的值。
```
#include <iostream>
int main()
{
    using namespace std;
    int updates = 6;
    int * p_updates;

    p_updates = &updates;
     cout << updates;
     cout << p_updates;

     *p_updates = *p_updates + 1;
     cout << updates;
     return 0;
}
```
int变量updates和指针变量p_updates只不过是同一枚硬币的两面。变量updates表示值，并使用&运算符来获得地址；而变量p_updates表示地址，并使用*运算符来获得值.。由于p_updates指向updates，因此*p_updates和updates完全等价。可以像使用int变量那样使用*p_updates。

### 4.7.1 声明和初始化指针
指针声明必须指定指针指向的数据的类型。
p_updates是指针（地址），而*p_updates是int，而不是指针。
```
int* p1,p2;
```
声明创建一个指针和一个int变量。对每个指针变量名，都需要使用一个*。

可以在声明语句中初始化指针。
```
int higgens = 5;
int *pt = &higgen;
```
### 4.7.2 指针的危险
在C++中创建指针时，计算机将分配用来存储地址的内存，但不会分配用来存储指针所指向的数据的内存。为数据提供空间是一个独立的步骤，忽略这一步无疑是自找麻烦
```
long *fellow;
*fellow = 223323;
```
上述代码没有将地址赋给fellow。由于fellow没有被初始化，它可能有任何值。不管值是什么，程序都将它解释为存储223323的地址。如果fellow的值碰巧为1200，计算机将把数据放在地址1200上，即使这恰巧是程序代码的地址。fellow指向的地方很可能并不是所要存储223323的地方。这种错误可能会导致一些最隐匿、最难以跟踪的bug。

一定要在对指针应用解除引用运算符（*）之前，将指针初始化为一个确定的、适当的地址。这是关于使用指针的金科玉律。
### 4.7.3 指针和数字
指针不是整型。不能简单地将整数赋给指针。

要将数字值作为地址来使用，应通过强制类型转换将数字转换为适当的地址类型。
### 4.7.4 使用new来分配内存
前面我们都将指针初始化为变量的地址；变量是在编译时分配的有名称的内存，而指针只是为可以通过名称直接访问的内存提供了一个别名。指针真正的用武之地在于，在运行阶段分配**未命名的内存以存储值**。在这种情况下，只能通过指针来访问内存。在C语言中，可以用库函数malloc( )来分配内存；在C++中仍然可以这样做，但C++还有更好的方法—new运算符。

在运行阶段为一个int值分配未命名的内存，并使用指针来访问这个值。这里的关键所在是C++的new运算符。程序员要告诉new，需要为哪种数据类型分配内存；new将找到一个长度正确的内存块，并返回该内存块的地址。程序员的责任是将该地址赋给一个指针。
```
int *pn = new int;
```
new int告诉程序，需要适合存储int的内存。new运算符根据类型来确定需要多少字节的内存。然后，它找到这样的内存，并返回其地址。接下来，将地址赋给pn，pn是被声明为指向int的指针。现在，pn是地址，而*pn是存储在那里的值。

我们说pn指向一个数据对象，这里的“对象”不是“面向对象编程”中的对象，而是一样“东西”。术语“数据对象”比“变量”更通用，它指的是为数据项分配的内存块。因此，变量也是数据对象，但pn指向的内存不是变量。乍一看，处理数据对象的指针方法可能不太好用，但它使程序在管理内存方面有更大的控制权。为一个数据对象（可以是结构，也可以是基本类型）获得并指定分配内存的通用格式如下：
```
typeName *pointer_name = new typeName;
```
需要在两个地方指定数据类型：用来指定需要什么样的内存和用来声明合适的指针。

new分配的内存块通常与常规变量声明分配的内存块不同。变量nights和pd的值都存储在被称为栈（stack）的内存区域中，而new从被称为堆（heap）或自由存储区（freestore）的内存区域分配内存。
### 4.7.5 使用delete释放内存
归还或释放（free）的内存可供程序的其他部分使用。使用delete时，后面要加上指向内存块的指针。
```
int *ps = new int;
...
delete ps;
```
这将释放ps指向的内存，但不会删除指针ps本身。一定要配对地使用new和delete；否则将发生内存泄漏（memory leak），也就是说，被分配的内存再也无法使用了。

不要尝试释放已经释放的内存块，C++标准指出，这样做的结果将是不确定的，这意味着什么情况都可能发生。另外，不能使用delete来释放声明变量所获得的内存：只能用delete来释放使用new分配的内存。然而，对空指针使用delete是安全的。

一般来说，不要创建两个指向同一个内存块的指针，因为这将增加错误地删除同一个内存块两次的可能性。但稍后您会看到，对于返回指针的函数，使用另一个指针确实有道理。
### 4.7.6 使用new来创建动态数组
对于大型数据（如数组、字符串和结构），应使用new，这正是new的用武之地。
在编译时给数组分配内存被称为**静态联编（static binding）**，意味着数组是在编译时加入到程序中的。但使用new时，如果在运行阶段需要数组，则创建它；如果不需要，则不创建。还可以在程序运行时选择数组的长度。这被称为**动态联编（dynamic binding）**，意味着数组是在程序运行时创建的。使用静态联编时，必须在编写程序时指定数组的长度；使用动态联编时，程序将在运行时确定数组的长度。
#### 1.使用new创建动态数组
只要将数组的元素类型和元素数目告诉new即可。必须在类型名后加上方括号，其中包含元素数目。
```
int *psome = new int[10];
```
new运算符返回第一个元素的地址。在这个例子中，该地址被赋给指针psome。
当程序使用完new分配的内存块时，应使用delete释放它们。
```
delete []psome;
```
方括号告诉程序，应释放整个数组，而不仅仅是指针指向的元素。请注意delete和指针之间的方括号。

使用new和delete时，应遵守以下规则。
- 不要使用delete来释放不是new分配的内存。
- 不要使用delete释放同一个内存块两次。
- 如果使用new [ ]为数组分配内存，则应使用delete [ ]来释放。
- 如果使用new [ ]为一个实体分配内存，则应使用delete（没有方括号）来释放。
- 对空指针应用delete是安全的。
psome是指向一个int（数组第一个元素）的指针。您的责任是跟踪内存块中的元素个数。
实际上，程序确实跟踪了分配的内存量，以便以后使用delete [ ]运算符时能够正确地释放这些内存。不能使用sizeof运算符来确定动态分配的数组包含的字节数。
为数组分配内存的通用格式如下：
```
type_name *pointer_name = new type_name[num_elements];
```
使用new运算符可以确保内存块足以存储num_elements个类型为type_name的元素，而pointer_name将指向第1个元素。下面将会看到，可以以使用数组名的方式来使用pointer_name。
#### 2.使用动态数组
