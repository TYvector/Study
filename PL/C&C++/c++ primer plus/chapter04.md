# 第4章 复合类型
## 4.1 数组
数组（array）是一种数据格式，能够存储多个同类型的值。计算机在内存中依次存储数组的各个元素。
数组声明应指出以下三点：
- 存储在每个元素中的值的类型；
- 数组名；
- 数组中的元素数。
在C++中，可以通过修改简单变量的声明，添加中括号（其中包含元素数目）来完成数组声明。
通用格式如下：
```
typeName arrayName[arraySize];
```
表达式arraySize指定元素数目，它必须是整型常数（如10）或const值，也可以是常量表达式（如8 * sizeof（int）），即其中所有的值在编译时都是已知的。
可以单独访问数组元素。方法是使用下标或索引来对元素进行编号。C++数组从0开始编号.C++使用带索引的方括号表示法来指定数组元素。注意，最后一个元素的索引比数组长度**小1**
```
#include <iostream>
int main()
{
    using namespace std;
    int yams[3];
    yam[0] = 7;
    yam[1] = 8;
    yam[2] = 6;
    int yamcosts[3] = {20 , 30 , 5};

    return 0;
}
```
### 4.1.1 程序说明
C++允许在声明语句中初始化数组元素。只需提供一个用逗号分隔的值列表（初始化列表），并将它们用花括号括起即可。
sizeof运算符返回类型或数据对象的长度（单位为字节）。注意，如果将sizeof运算符用于数组名，得到的将是整个数组中的字节数。但如果将sizeof用于数组元素，则得到的将是元素的长度（单位为字节）。
### 4.1.2 数组的初始化规则
只有在定义数组时才能使用初始化，此后就不能使用了，也不能将一个数组赋给另一个数组：
```
int cards[4] = {3,6,8,10};   //okay
int hands[4];               //okay
hands[4] = {5,6,7,9};       //not allowed
hands = cards;              //not allowed
```
可以使用下标分别给数组中的元素赋值。
初始化数组时，提供的值可以少于数组的元素数目。
如果只对数组的一部分进行初始化，则编译器将把其他元素设置为0。因此，将数组中所有的元素都初始化为0非常简单—只要显式地将第一个元素初始化为0，然后让编译器将其他元素都初始化为0即可：
```
long totals[500] = {0};
```
如果初始化数组时方括号内（[ ]）为空，C++编译器将计算元素个数。
### 4.1.3 C++11数组初始化方法
初始化数组时，可省略等号（=）
可不在大括号内包含任何东西，这将把所有元素都设置为零
```
double earnings[4] {1.2e4,1.6e4,1.1e4,1.7e4};
unsigned int counts[10] = {};
float balances[100]{};
```
列表初始化禁止缩窄转换
C++标准模板库（STL）提供了一种数组替代品—模板类vector，而C++11新增了模板类array。
## 4.2 字符串
字符串是存储在内存的连续字节中的一系列字符。C++处理字符串的方式有两种。第一种来自C语言，常被称为**C-风格字符串**（C-stylestring）。
以空字符（null character）结尾，空字符被写作\0，其ASCII码为0，用来标记字符串的结尾。
空字符对C-风格字符串而言至关重要。
不应将不是字符串的字符数组当作字符串来处理。
只需使用一个用引号括起的字符串即可，这种字符串被称为**字符串常量**（string constant）或**字符串字面值**（string literal）
```
char bird[11] = "Mr.Cheeps";
char fish[] = "Bubbles";
```
用引号括起的字符串隐式地包括结尾的空字符,各种C++输入工具通过键盘输入，将字符串读入到char数组中时，将自动加上结尾的空字符
应确保数组足够大，能够存储字符串中所有字符—包括空字符。使用字符串常量初始化字符数组是这样的一种情况，即让编译器计算元素数目更为安全。C++对字符串长度没有限制。
但"S"不是字符常量，它表示的是两个字符（字符S和\0）组成的字符串。更糟糕的是，"S"实际上表示的是字符串所在的内存地址。因此下面的语句试图将一个内存地址赋给shirt_size：
```
char shirt_size = "S";
```
由于地址在C++中是一种独立的类型，因此C++编译器不允许这种不合理的做法
### 4.2.1 拼接字符串常量
C++允许拼接字符串字面值，即将两个用引号括起的字符串合并为一个。任何两个由空白（空格、制表符和换行符）分隔的字符串常量都将自动拼接成一个。
拼接时不会在被连接的字符串之间添加空格，第二个字符串的第一个字符将紧跟在第一个字符串的最后一个字符（不考虑\0）后面。第一个字符串中的\0字符将被第二个字符串的第一个字符取代。
### 4.2.2 在数组中使用字符串
最常用的方法有两种—将数组初始化为字符串常量、将键盘或文件输入读入到数组中。
strlen( )函数返回的是存储在数组中的字符串的长度，而不是数组本身的长度。数组的长度不能短于strlen（ ）+1。
### 4.2.3 字符串输入
cin是如何确定已完成字符串输入呢？由于不能通过键盘输入空字符，因此cin需要用别的方法来确定字符串的结尾位置。cin使用空白（空格、制表符和换行符）来确定字符串的结束位置，这意味着cin在获取字符数组输入时只读取一个单词。读取该单词后，cin将该字符串放到数组中，并自动在结尾添加空字符。
另一个问题是，输入字符串可能比目标数组长。
### 4.2.4 每次读取一行字符串输入
每次读取一个单词通常不是最好的选择。具体地说，需要采用面向行而不是面向单词的方法。istream中的类（如cin）提供了一些面向行的类成员函数：getline( )和get( )。这两个函数都读取一行输入，直到到达换行符。随后getline( )将丢弃换行符，而get( )将换行符保留在输入序列中。
#### 面向行的输入：getline( )
getline( )函数读取整行，它使用通过回车键输入的换行符来确定输入结尾。要调用这种方法，可以使用cin.getline( )。该函数有两个参数。第一个参数是用来存储输入行的数组的名称，第二个参数是要读取的字符数。如果这个参数为20，则函数最多读取19个字符，余下的空间用于存储自动在结尾处添加的空字符。getline( )成员函数在读取指定数目的字符或遇到换行符时停止读取。

`cin.getine(name,20);`

#### 面向行的输入：get( )
istream类有另一个名为get( )的成员函数，该函数有几种变体。其中一种变体的工作方式与getline( )类似，它们接受的参数相同，解释参数的方式也相同，并且都读取到行尾。但get并不再读取并丢弃换行符，而是将其留在输入队列中。假设我们连续两次调用get( )：
由于第一次调用后，换行符将留在输入队列中，因此第二次调用时看到的第一个字符便是换行符。因此get( )认为已到达行尾，而没有发现任何可读取的内容。如果不借助于帮助，get( )将不能跨过该换行符。
使用不带任何参数的cin.get( )调用可读取下一个字符（即使是换行符），因此可以用它来处理换行符，为读取下一行输入做好准备。
```
cin.get(name,ArSize);
cin.get();
cin.get(dessert,ArSize);
```
另一种使用get( )的方式是将两个类成员函数拼接起来（合并）
```
cin.get(name,ArSize).get();
```
是由于cin.get（name，ArSize）返回一个cin对象，该对象随后将被用来调用get( )函数。
同样，下面的语句将把输入中连续的两行分别读入到数组name1和name2 中，其效果与两次调用cin.getline( )相同：
```
cin.getline(name1,ArSize).getline(name2,ArSize);
```
C++允许函数有多个版本，条件是这些版本的参数列表不同。
getline( )使用起来简单一些，但get( )使得检查错误更简单些。
#### 空行和其他问题
当get( )（不是getline( )）读取空行后将设置失效位（failbit）。这意味着接下来的输入将被阻断，但可以用下面的命令来恢复输入：
```
cin.clear();
```
如果输入行包含的字符数比指定的多，则getline( )和get( )将把余下的字符留在输入队列中，而getline( )还会设置失效位，并关闭后面的输入。
### 4.2.5 混合输入字符串和数字
当cin读取年份，将回车键生成的换行符留在了输入队列中。后面的cin.getline( )看到换行符后，将认为是一个空行，并将一个空字符串赋给address数组。解决之道是，在读取地址之前先读取并丢弃换行符。这可以通过几种方法来完成，其中包括使用没有参数的get( )和使用接受一个char参数的get( )，可以单独进行调用：
```
cin >> year;
cin.get(); // or cin.get(ch);
```
也可以利用表达式cin>>year返回cin对象，将调用拼接起来：
```
(cin >> year).get(); //or (cin>>year).get(ch);
```
C++程序常使用指针（而不是数组）来处理字符串。
## 4.3 string类简介
要使用string类，必须在程序中包含头文件string。string类位于名称空间std中，因此您必须提供一条using编译指令，或者使用std::string来引用它。string类定义隐藏了字符串的数组性质，让您能够像处理普通变量那样处理字符串。
在很多方面，使用string对象的方式与使用字符数组相同。
- 可以使用C-风格字符串来初始化string对象。
- 可以使用cin来将键盘输入存储到string对象中。
- 可以使用cout来显示string对象。
- 可以使用数组表示法来访问存储在string对象中的字符。
可以将string对象声明为简单变量，而不是数组
### 4.3.1 C++11字符串初始化
C++11也允许将列表初始化用于C-风格字符串和string对象
### 4.3.2 赋值、拼接和附加
不能将一个数组赋给另一个数组，但可以将一个string对象赋给另一个string对象：
string类简化了字符串合并操作。可以使用运算符+将两个string对象合并起来，还可以使用运算符+=将字符串附加到string对象的末尾。
### 4.3.3 string类的其他操作
头文件cstring（以前为string.h）提供了这些函数。可以使用
函数strcpy( )将字符串复制到字符数组中，使用函数strcat( )将字符串附加到字符数组末尾：
string类具有自动调整大小的功能。C函数库确实提供了与strcat( )和strcpy( )类似的函数—strncat( )和strncpy( )，它们接受指出目标数组最大允许长度的第三个参数
下面是两种确定字符串中字符数的方法：
```
int len1 = str1.size();
int len2 = strlen(charr1);
```
### 4.3.4 string类I/O
未初始化的数组的内容是未定义的；函数strlen( )从数组的第一个元素开始计算字节数，直到遇到空字符。
未被初始化的string对象的长度被自动设置为0。
下面是将一行输入读取到string对象中的代码
```
getline(cin,str);
```
### 4.3.5 其他形式的字符串字面值
除char类型外，C++还有类型wchar_t；而C++11新增了类型char16_t和char32_t。可创建这些类型的数组和这些类型的字符串字面值。C++分别使用前缀L、u和U表示，
C++使用前缀u8来表示UTF-8。
C++11新增的另一种类型是原始（raw）字符串。在原始字符串中，字符表示的就是自己，例如，序列\n不表示换行符，而表示两个常规字符—斜杠和n
原始字符串将"(和)"用作定界符，并使用前缀R来标识原始字符串：
原始字符串语法允许您在表示字符串开头的"和(之间添加其他字符，这意味着表示字符串结尾的"和)之间也必须包含这些字符。
自定义定界符时，在默认定界符之间添加任意数量的基本字符，但空格、左括号、右括号、斜杠和控制字符（如制表符和换行符）除外。
可将前缀R与其他字符串前缀结合使用
## 4.4 结构简介
结构是一种比数组更灵活的数据格式，因为同一个结构可以存储多种类型的数据
结构也是C++ OOP堡垒（类）的基石。
结构是用户定义的类型，而结构声明定义了这种类型的数据属性。定义了类型后，便可以创建这种类型的变量。因此创建结构包括两步。首先，**定义结构描述**—它描述并标记了能够存储在结构中的各种数据类型。然后按描述**创建结构变量**（结构数据对象）。
```
struct inflatable
{
    char name[20];
    float volume;
    double price;
}
```
关键字struct表明，这些代码定义的是一个结构的布局。标识符inflatable是这种数据格式的名称.这样，便可以像创建char或int类型的变量那样创建inflatable类型的变量了。接下来的大括号中包含的是结构存储的数据类型的列表，其中每个列表项都是一条声明语句。列表中的每一项都被称为结构成员，因此infatable结构有3个成员
定义结构后，便可以创建这种类型的变量了：
C++允许在声明结构变量时省略关键字struct,在C++中，结构标记的用法与基本类型名相同。
通过成员名能够访问结构的成员，就像通过索引能够访问数组的元素一样。
### 4.4.1 在程序中使用结构
```
#include <iostream>
struct inflatable
{
    char name[20];
    float volume;
    double price;
};

int main()
{
    using namespace std;
    inflatable guest =
    {
        "Glorious Gloria",
        1.88,
        2.99
    };

    inflatable pal = 
    {
        "Audacious Arthur",
        3.12,
        32.99
    };

    cout << guest.name << endl;
    cout << guest.price + pal.price << endl;

    return 0;
}
```
结构声明的位置很重要。有两种选择。可以将声明放在main( )函数中，紧跟在开始括号的后面。另一种选择是将声明放到main( )的前面，这里采用的便是这种方式，位于函数外面的声明被称为外部声明。外部声明可以被其后面的任何函数使用，而内部声明只能被该声明所属的函数使用。

变量也可以在函数内部和外部定义，外部变量由所有的函数共享.

和数组一样，使用由逗号分隔值列表，并将这些值用花括号括起。可将每个结构成员看作是相应类型的变量。
### 4.4.2 C++11结构初始化
与数组一样，C++11也支持将列表初始化用于结构，且等号（=）是可选的：
如果大括号内未包含任何东西，各个成员都将被设置为零。
最后，不允许缩窄转换。
### 4.4.3 结构可以将string类作为成员吗
答案是肯定的

一定要让结构定义能够访问名称空间std。为此，可以将编译指令using移到结构定义之前；也可以将name的类型声明为std::string。
### 4.4.4 其他结构属性
C++使用户定义的类型与内置类型尽可能相似。可以将结构作为参数传递给函数，也可以让函数返回一个结构。另外，还可以使用赋值运算符（=）将结构赋给另一个同类型的结构，这样结构中每个成员都将被设置为另一个结构中相应成员的值，即使成员是数组。这种赋值被称为**成员赋值**（memberwise assignment）

可以同时完成定义结构和创建结构变量的工作。为此，只需将变量名放在结束括号的后面即可：甚至可以初始化以这种方式创建的变量：

还可以声明没有名称的结构类型，方法是省略名称，同时定义一种结构类型和一个这种类型的变量
```
struct
{
    int x;
    int y;
} position;
```
### 4.4.5 结构数组
也可以创建元素为结构的数组，方法和创建基本类型数组完全相同。
```
inflatable gifts[100];
```
要初始化结构数组，可以结合使用初始化数组的规则（用逗号分隔每个元素的值，并将这些值用花括号括起）和初始化结构的规则（用逗号分隔每个成员的值，并将这些值用花括号括起）。最终结果为一个被括在花括号中、用逗号分隔的值列表，其中每个值本身又是一个被括在花括号中、用逗号分隔的值列表：
```
inflatable guest[2] = 
{
    {"Bambi",0.5,21.99},
    {"Godzilla",2000,565.99}
}
```
### 4.4.6 结构中的位字段
C++也允许指定占用特定位数的结构成员,字段的类型应为整型或枚举（稍后将介绍），接下来是冒号，冒号后面是一个数字，它指定了使用的位数。
```
struct torgle_register
{
    unsigned int SN : 4;
    unsigned int : 4;
    bool goodIn : 1;
    bool goodTorgle : 1;
}
```
## 4.5 共用体
共用体（union）是一种数据格式，它能够存储不同的数据类型，但只能同时存储其中的一种类型。也就是说，结构可以同时存储int、long和double，共用体只能存储int、long或double。共用体的句法与结构相似，但含义不同。
```
union one4all
{
    int int_val;
    long long_val;
    double double_val;
}
```
成员名称标识了变量的容量。由于共用体每次只能存储一个值，因此它必须有足够的空间来存储最大的成员，所以，共用体的长度为其最大成员的长度。
共用体的用途之一是，当数据项使用两种或更多种格式（但不会同时使用）时，可节省空间.
```
struct widget
{
    char brand[20];
    int type;
    union id
    {
        long id_num;
        char id_char[20];
    } id_val;
};
···
widget prize;
···
if (prize.type == 1)
    cin >> prize.id_val.id_num;
else
    cin >> prize.id_val.id_char;

```

匿名共用体（anonymous union）没有名称，其成员将成为位于相同地址处的变量。显然，每次只有一个成员是当前的成员：
```
struct widget
{
    char brand[20];
    int type;
    union
    {
        long id_num;
        char id_char[20];
    };
};
```
由于共用体是匿名的，因此id_num和id_char被视为prize的两个成员，它们的地址相同，所以不需要中间标识符id_val。
共用体常用于（但并非只能用于）节省内存。
## 4.6 枚举
C++的enum工具提供了另一种创建符号常量的方式，这种方式可以代替const。它还允许定义新类型，但必须按严格的限制进行。使用enum的句法与使用结构相似。
```
enum spectrum {red, orange, yellow, green, blue, violet, indigo, ultraviolet};
```
这条语句完成两项工作。
- 让spectrum成为新类型的名称；spectrum被称为**枚举**（enumeration），就像struct变量被称为结构一样。
- 将red、orange、yellow等作为符号常量，它们对应整数值0～7。这些常量叫作**枚举量**（enumerator）。
在默认情况下，将整数值赋给枚举量，第一个枚举量的值为0，第二个枚举量的值为1，依次类推。可以通过显式地指定整数值来覆盖默认值，可以用枚举名来声明这种类型的变量：
```
spectrum band;
```
在不进行强制类型转换的情况下，只能将定义枚举时使用的枚举量赋给这种枚举的变量，因此，spectrum变量受到限制，只有8个可能的值。对于枚举，只定义了赋值运算符。具体地说，没有为枚举定义算术运算
```
band = blue;
band = orange;
```
枚举量是整型，可被提升为int类型，但int类型不能自动转换为枚举类型：
```
int color = blue;
band = 3;           //invalid
color = 3 + red;
```
3对应的枚举量是green，但将3赋给band将导致类型错误。不过将green赋给band是可以的，因为它们都是spectrum类型。表达式3 + red中的加法并非为枚举量定义，但red被转换为int类型，因此结果的类型也是int。由于在这种情况下，枚举将被转换为int，因此可以在算术表达式中同时使用枚举和常规整数，尽管并没有为枚举本身定义算术运算。
```
band = orange + red;    //not valid, but a little tricky
```
非法的原因有些复杂。确实没有为枚举定义运算符+，但用于算术表达式中时，枚举将被转换为整数，因此表达式orange + red将被转换为1 + 0。这是一个合法的表达式，但其类型为int，不能将其赋给类型为spectrum的变量band。如果int值是有效的，则可以通过强制类型转换，将它赋给枚举变量
```
band = spectrum(3);
```
如果试图对一个不适当的值进行强制类型转换，将出现什么情况呢？结果是不确定的，这意味着这样做不会出错，但不能依赖得到的结果：
枚举更常被用来定义相关的符号常量，而不是新类型。可以用枚举来定义switch语句中使用的符号常量,如果打算只使用常量，而不创建枚举类型的变量，则可以省略枚举类型的名称.
### 4.6.1 设置枚举量的值
可以使用赋值运算符来显式地设置枚举量的值：指定的值必须是整数。也可以只显式地定义其中一些枚举量的值：可以创建多个值相同的枚举量：
```
enum bits{one = 1, two = 2, four = 4, eight = 8};
enum bigstep{first, second = 100, third};
enum {zero, null  = 0, one, numero_uno = 1};
```
first在默认情况下为0。后面没有被初始化的枚举量的值将比其前面的枚举量大1。因此，third的值为101。zero和null都为0，one和umero_uno都为1。
### 4.6.2 枚举的取值范围
最初，对于枚举来说，只有声明中指出的那些值是有效的。然而，C++现在通过强制类型转换，增加了可赋给枚举变量的合法值。每个枚举都有取值范围（range），通过强制类型转换，可以将取值范围中的任何整数值赋给枚举变量，即使这个值不是枚举值。
```
enum bits{one = 1, two = 2, four = 4, eight = 8};
bits myflag;
myflag = bits(6);
```
其中6不是枚举值，但它位于枚举定义的取值范围内。
取值范围的定义如下。首先，要找出上限，需要知道枚举量的最大值。找到大于这个最大值的、最小的2的幂，将它减去1，得到的便是取值范围的上限。例如，前面定义的bigstep的最大值枚举值是101。在2的幂中，比这个数大的最小值为128，因此取值范围的上限为127。要计算下限，需要知道枚举量的最小值。如果它不小于0，则取值范围的下限为0；否则，采用与寻找上限方式相同的方式，但加上负号。例如，如果最小的枚举量为−6，而比它小的、最大的2的幂是−8（加上负号），因此下限为−7。
C++11扩展了枚举，增加了**作用域内枚举**（scoped enumeration），
## 4.7 指针和自由存储空间