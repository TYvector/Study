# 第7章 函数——C++的编程模块
## 7.1 复习函数的基本知识
要使用C++函数，必须：
- 提供函数定义；
- 提供函数原型；
- 调用函数。

库函数是已经定义和编译好的函数，同时可以使用标准库头文件提供其原型，因此只需正确地调用这种函数即可。
### 7.1.1 定义函数
可以将函数分成两类：没有返回值的函数和有返回值的函数。没有返回值的函数被称为void函数，其通用格式如下：
```
void functionName(parameterList)
{
    statement(s)
    return;             //optional
}
```
parameterList指定了传递给函数的参数类型和数量。可选的返回语句标记了函数的结尾；否则，函数将在右花括号处结束。通常，可以用void函数来执行某种操作。

有返回值的函数将生成一个值，并将它返回给调用函数。这种函数的类型被声明为返回值的类型，其通用格式如下：
```
typeName functionName(parameterList)
{
    statements
    return value;
}
```
对于有返回值的函数，必须使用返回语句，以便将值返回给调用函数。值本身可以是常量、变量，也可以是表达式，只是其结果的类型必须为typeName类型或可以被转换为typeName。C++对于返回值的类型有一定的限制：不能是数组，但可以是其他任何类型——整数、浮点数、指针，甚至可以是结构和对象！

通常，函数通过将返回值复制到指定的CPU寄存器或内存单元中来将其返回。随后，调用程序将查看该内存单元。返回函数和调用函数必须就该内存单元中存储的数据的类型达成一致。函数原型将返回值类型告知调用程序，而函数定义命令被调用函数应返回什么类型的数据。

函数在执行返回语句后结束。如果函数包含多条返回语句（例如，它们位于不同的if else选项中），则函数在执行遇到的第一条返回语句后结束。

### 7.1.2 函数原型和函数调用
#### 1.为什么需要原型
原型描述了函数到编译器的接口，也就是说，它将函数返回值的类型（如果有的话）以及参数的类型和数量告诉编译器。
```
double volume = cube(side);
```
首先，原型告诉编译器，cube( )有一个double参数。如果程序没有提供这样的参数，原型将让编译器能够捕获这种错误。其次，cube( )函数完成计算后，将把返回值放置在指定的位置——可能是CPU寄存器，也可能是内存中。然后调用函数（这里为main( )）将从这个位置取得返回值。由于原型指出了cube( )的类型为double，因此编译器知道应检索多少个字节以及如何解释它们。
#### 2.原型的语法
函数原型是一条语句，因此必须以分号结束。获得原型最简单的方法是，复制函数定义中的函数头，并添加分号。
```
double cube(double x);
void cheers(int);
```
通常，在原型的参数列表中，可以包括变量名，也可以不包括。原型中的变量名相当于占位符，因此不必与函数定义中的变量名相同。

在C++中，不指定参数列表时应使用省略号：
```
void say_bye(...);
```
#### 3.原型的功能
- 编译器正确处理函数返回值；
- 编译器检查使用的参数数目是否正确；
- 编译器检查使用的参数类型是否正确。如果不正确，则转换为正确的类型（如果可能的话）。

仅当有意义时，原型化才会导致类型转换。例如，原型不会将整数转换为结构或指针。

在编译阶段进行的原型化被称为静态类型检查（static type checking）。可以看出，静态类型检查可捕获许多在运行阶段非常难以捕获的错误。
## 7.2 函数参数和按值传递
C++通常按值传递参数，这意味着将数值参数传递给函数，而后者将其赋给一个新的变量。
```
double volume = cube(side);

double cube(double x)
```
被调用时，该函数将创建一个新的名为x的double变量，并将其初始化为5。这样，cube( )执行的操作将不会影响main( )中的数据，因为cube( )使用的是side的副本，而不是原来的数据。用于接收传递值的变量被称为形参。传递给函数的值被称为实参。出于简化的目的，C++标准使用参数（argument）来表示实参，使用参量（parameter）来表示形参，因此参数传递将参量赋给参数。

在函数中声明的变量（包括参数）是该函数私有的。在函数被调用时，计算机将为这些变量分配内存；在函数结束时，计算机将释放这些变量使用的内存。这样的变量被称为局部变量，这样的变量也被称为自动变量，因为它们是在程序执行过程中自动被分配和释放的。
### 7.2.1 多个参数
函数可以有多个参数。在调用函数时，只需使用逗号将这些参数分开即可。同样，在定义函数时，也在函数头中使用由逗号分隔的参数声明列表。如果函数的两个参数的类型相同，则必须分别指定每个参数的类型，而不能像声明常规变量那样，将声明组合在一起。和一个参数的情况一样，原型中的变量名不必与定义中的变量名相同，而且可以省略。
### 7.2.2 另外一个接受两个参数的函数
## 7.3 函数和数组
```
int sum_arr(int arr[], int n)
```
arr实际上并不是数组，而是一个指针！在编写函数的其余部分时，可以将arr看作是数组。
### 7.3.1 函数如何使用指针来处理数组
C++将数组名解释为其第一个元素的地址。

该规则有一些例外。首先，数组声明使用数组名来标记存储位置；其次，对数组名使用sizeof将得到整个数组的长度（以字节为单位）；第三，将地址运算符&用于数组名时，将返回整个数组的地址。
```
int sum_arr(int * arr ,int n)
```
其中用int * arr替换了int arr [ ]。这证明这两个函数头都是正确的，因为在C++中，当（且仅当）用于函数头或函数原型中，int *arr和int arr[ ]的含义才是相同的。它们都意味着arr是一个int指针。然而，数组表示法（int arr[ ]）提醒用户，arr不仅指向int，还指向**int数组的第一个int**。当指针指向**数组的第一个元素**时，本书使用数组表示法；而当指针指向**一个独立的值**时，使用指针表示法。
```
arr[i] = *(ar + i)
&arr[i] = ar + i
```
将指针（包括数组名）加1，实际上是加上了一个与指针指向的类型的长度（以字节为单位）相等的值。
### 7.3.2 将数组作为参数意味着什么
程序实际上并没有将数组内容传递给函数，而是将数组的位置（地址）、包含的元素种类（类型）以及元素数目（n变量）提交给函数。有了这些信息后，函数便可以使用原来的数组。传递常规变量时，函数将使用该变量的拷贝；但传递数组时，函数将使用原来的数组。

数组名与指针对应是好事吗？确实是一件好事。将数组地址作为参数可以节省复制整个数组所需的时间和内存。如果数组很大，则使用拷贝的系统开销将非常大；程序不仅需要更多的计算机内存，还需要花费时间来复制大块的数据。另一方面，使用原始数据增加了破坏数据的风险。ANSI C和C++中的const限定符提供了解决这种问题的办法。

指针本身并没有指出数组的长度。

为将数组类型和元素数量告诉数组处理函数，请通过两个不同的参数来传递它们，而不要试图使用方括号表示法来传递数组长度：
```
void fillArray(int arr[] , int size);

void fillArray(int arr[size]);
```
### 7.3.3 更多数组函数示例
#### 显示数组及用const保护数组
为防止函数无意中修改数组的内容，可在声明形参时使用关键字const
```
void show_array(const double ar[], int n);
```
这并不是意味着原始数组必须是常量，而只是意味着不能在show_array( )函数中使用ar来修改这些数据。因此，show_array( )将数组视为只读数据。

**自下而上的程序设计（bottom-up programming）**，因为设计过程从组件到整体进行。这种方法非常适合于OOP——它首先强调的是数据表示和操纵。而传统的过程性编程倾向于**从上而下的程序设计（top-down programming**）**，首先指定模块化设计方案，然后再研究细节。
#### 数组处理函数的常用编写方式
```
void f_modify(double ar[], int n);              //修改数组
void _f_no_change(const double ar[], int n);    //不修改数组
```
ar实际上是一个指针，指向传入的数组的第一个元素；另外，由于通过参数传递了元素数，这两个函数都可使用任何长度的数组。函数缺少一些有关原始数组的知识；例如，它不能使用sizeof来获悉原始数组的长度。
### 7.3.4 使用数组区间的函数
还有另一种给函数提供所需信息的方法，即指定元素区间（range），这可以通过传递两个指针来完成：一个指针标识数组的开头，另一个指针标识数组的尾部。C++标准模板库（STL，将在第16章介绍）将区间方法广义化了。STL方法使用“超尾”概念来指定区间。也就是说，对于数组而言，标识数组结尾的参数将是指向最后一个元素后面的指针。
### 7.3.5 指针和const
可以用两种不同的方式将const关键字用于指针。第一种方法是让指针指向一个常量对象，这样可以防止使用该指针来修改所指向的值，第二种方法是将指针本身声明为常量，这样可以防止改变指针指向的位置。
```
int age = 39;
const int * pt = &age;
```
该声明指出，pt指向一个const int（这里为39），因此不能使用pt来修改这个值。换句话来说，*pt的值为const，不能被修改。pt的声明并不意味着它指向的值实际上就是一个常量，而只是意味着对pt而言，这个值是常量。例如，pt指向age，而age不是const。可以直接通过age变量来修改age的值，但不能使用pt指针来修改它。

将const变量的地址赋给指向const的指针。C++禁止将const的地址赋给非const指针。

仅当只有一层间接关系（如指针指向基本数据类型）时，才可以将非const地址或指针赋给const指针。

如果数据类型本身并不是指针，则可以将const数据或非const数据的地址赋给指向const的指针，但只能将非const数据的地址赋给非const指针。
```
int sloth = 3;
const int *ps = &sloth;
int * const finger = &sloth;
```
第一个声明只能防止修改指向的值，而不能防止修改ps的值。也就是说，可以将一个新地址赋给ps。第二种使用const的方式使得无法修改指针的值。这种声明格式使得finger只能指向sloth，但允许使用finger来修改sloth的值。中间的声明不允许使用ps来修改sloth的值，但允许将ps指向另一个位置。简而言之，finger和* ps都是const，而*finger和ps不是。

如果愿意，还可以声明指向const对象的const指针

通常，将指针作为函数参数来传递时，可以使用指向const的指针来保护数据。
```
void show_array(const double ar[], int n);
```
在该声明中使用const意味着show_array( )不能修改传递给它的数组中的值。只要只有一层间接关系，就可以使用这种技术。例如，这里的数组元素是基本类型，但如果它们是指针或指向指针的指针，则不能使用const。
## 7.4 函数和二维数组
为编写将二维数组作为参数的函数，必须牢记，数组名被视为其地址，因此，相应的形参是一个指针，就像一维数组一样。比较难处理的是如何正确地声明指针。
```
int data[3][4] = {{1,2,3,4},{9,8,7,6},{2,4,6,8}};
int total = sum(data, 3);

int sum(int (*ar2)[4], int size);
```
Data是一个数组名，该数组有3个元素。第一个元素本身是一个数组，有4个int值组成。因此data的类型是指向由4个int组成的数组的指针。其中的括号是必不可少的，因为下面的声明将声明一个由4个指向int的指针组成的数组，而不是由一个指向由4个int组成的数组的指针；另外，函数参数不能是数组。

还有另外一种格式，这种格式与上述原型的含义完全相同
```
int sum(int ar2[][4], int size);
```
上述两个原型都指出，ar2是指针而不是数组。还需注意的是，指针类型指出，它指向由4个int组成的数组。因此，指针类型指定了列数，这就是没有将列数作为独立的函数参数进行传递的原因。

由于指针类型指定了列数，因此sum( )函数只能接受由4列组成的数组。但长度变量指定了行数，因此sum( )对数组的行数没有限制：

由于参数ar2是指向数组的指针，那么我们如何在函数定义中使用它呢？最简单的方法是将ar2看作是一个二维数组的名称。
## 7.5 函数和C-风格字符串
将字符串作为参数时意味着传递的是地址，但可以使用const来禁止对字符串参数进行修改。
### 7.5.1 将C-风格字符串作为参数的函数
表示字符串的方式有三种
- char数组
- 用引号括起的字符串常量（也称字符串字面值）
- 被设置为字符串的地址的char指针

上述3种选择的类型都是char指针（准确地说是char*），因此可以将其作为字符串处理函数的参数，可以说是将字符串作为参数来传递，但实际传递的是字符串第一个字符的地址。这意味着字符串函数原型应将其表示字符串的形参声明为char *类型。

C-风格字符串与常规char数组之间的一个重要区别是，字符串有内置的结束字符（前面讲过，包含字符，但不以空值字符结尾的char数组只是数组，而不是字符串）。这意味着不必将字符串长度作为参数传递给函数，而函数可以使用循环依次检查字符串中的每个字符，直到遇到结尾的空值字符为止。
### 7.5.2 返回C-风格字符串的函数
函数无法返回一个字符串，但可以返回字符串的地址。

这种设计（让函数返回一个指针，该指针指向new分配的内存）的缺点是，程序员必须记住使用delete。
## 7.6 函数和结构
在涉及到函数时，结构变量的行为更接近于基本的单值变量。与数组不同，结构将其数据组合成单个实体或数据对象，该实体被视为一个整体。可以将一个结构赋给另外一个结构。同样，也可以按值传递结构，就像普通变量那样。在这种情况下，函数将使用原始结构的副本。另外，函数也可以返回结构。与数组名就是数组第一个元素的地址不同的是，结构名只是结构的名称，要获得结构的地址，必须使用地址运算符&。

使用结构编程时，最直接的方式是像处理基本类型那样来处理结构；也就是说，将结构作为参数传递，并在需要时将结构用作返回值使用。然而，按值传递结构有一个缺点。如果结构非常大，则复制结构将增加内存要求，降低系统运行的速度。出于这些原因（同时由于最初C语言不允许按值传递结构），许多C程序员倾向于传递结构的地址，然后使用指针来访问结构的内容。C++提供了第三种选择——按引用传递（将在第8章介绍）。下面介绍其他两种传递方式，首先介绍传递和返回整个结构。
### 7.6.1 传递和返回结构
当结构比较小时，按值传递结构最合理。
### 7.6.3 传递结构的地址
- 调用函数时，将结构的地址（&pplace）而不是结构本身（pplace）传递给它；
- 将形参声明为指向polar的指针，即polar *类型。由于函数不应该修改结构，因此使用了const修饰符；
- 由于形参是指针而不是结构，因此应间接成员运算符（->），而不是成员运算符（句点）。

为了充分利用指针的效率，应使用指针，而不是返回值。为此，需要将两个指针传递给该函数。第一个指针指向要转换的结构，第二个指针指向存储转换结果的结构。函数不返回一个新的结构，而是修改调用函数中已有的结构。
## 7.7 函数和string对象
虽然C-风格字符串和string对象的用途几乎相同，但与数组相比，string对象与结构的更相似。如果需要多个字符串，可以声明一个string对象数组，而不是二维char数组。
## 7.8 函数与array对象
在C++中，类对象是基于结构的，因此结构编程方面的有些考虑因素也适用于类。例如，可按值将对象传递给函数，在这种情况下，函数处理的是原始对象的副本。另外，也可传递指向对象的指针，这让函数能够操作原始对象。

假设您要使用一个array对象来存储一年四个季度的开支：
```
std::array<double, 4> expenses;
```
要使用array类，需要包含头文件array，而名称array位于名称空间std中。如果函数来显示expenses的内容，可按值传递expenses：
```
show(expenses);
```
但如果函数要修改对象expenses，则需将该对象的地址传递给函数
```
fill(&expense);
```
如何声明这两个函数呢？expenses的类型为array< double, 4 >，因此必须在函数原型中指定这种类型：
```
void show(std::array<double, 4> da);
void fill(std::array<double, 4> *pa);
```
## 7.9 递归
C++函数有一种有趣的特点——可以调用自己（然而，与C语言不同的是，C++不允许main( )调用自己），这种功能被称为递归。
### 7.9.1 包含一个递归调用的递归
如果递归函数调用自己，则被调用的函数也将调用自己，这将无限循环下去，除非代码中包含终止调用链的内容。通常的方法将递归调用放在if语句中。例如，void类型的递归函数recurs( )的代码如下：
void recurs(argumentlist)
{
    statements1
    if (test)
        recurs(arguments)
    statements2
}
test最终将为false，调用链将断开。
### 7.9.2 包含多个递归调用的递归
递归方法有时被称为分而治之策略（divide-and-conquer strategy）。
## 7.10 函数指针
与数据项相似，函数也有地址。函数的地址是存储其机器语言代码的内存的开始地址。可以编写将另一个函数的地址作为参数的函数。这样第一个函数将能够找到第二个函数，并运行它。与直接调用另一个函数相比，这种方法很笨拙，但它允许在不同的时间传递不同函数的地址，这意味着可以在不同的时间使用不同的函数。
### 7.10.1 函数指针的基础知识
假设要设计一个名为estimate( )的函数，估算编写指定行数的代码所需的时间，并且希望不同的程序员都将使用该函数。对于所有的用户来说，estimate( )中一部分代码都是相同的，但该函数允许每个程序员提供自己的算法来估算时间。为实现这种目标，采用的机制是，将程序员要使用的算法函数的地址传递给estimate( )。为此，必须能够完成下面的工作：
- 获取函数的地址；
- 声明一个函数指针；
- 使用函数指针来调用函数。

#### 1.获取函数的地址
获取函数的地址很简单：只要使用函数名（后面不跟参数）即可。
#### 2.声明函数指针
声明指向函数的指针时，也必须指定指针指向的函数类型。这意味着声明应指定函数的返回类型以及函数的特征标（参数列表）。也就是说，声明应像函数原型那样指出有关函数的信息。
```
double pam(int);    //原型

double (*pf)(int);  //函数指针
```
这与pam( )声明类似，这是将pam替换为了（* pf）。由于pam是函数，因此（* pf）也是函数。而如果（*pf）是函数，则pf就是函数指针。

因此* pf（int）意味着pf( )是一个返回指针的函数，而（*pf）（int）意味着pf是一个指向函数的指针

正确地声明pf后，便可以将相应函数的地址赋给它：
```
pf = pam;
```
pam( )的特征标和返回类型必须与pf相同。如果不相同，编译器将拒绝这种赋值。

使用函数指针时，比较棘手的是编写原型，而传递地址则非常简单。
#### 3.使用指针来调用函数
前面讲过，（* pf）扮演的角色与函数名相同，因此使用（*pf）时，只需将它看作函数名即可
```
double y = (*pf)(5);
```
C++也允许像使用函数名那样使用pf：
```
double y = pf(5);
```
### 7.10.2 函数指针示例
### 7.10.3 深入探讨函数指针
鉴于需要使用三个函数，如果有一个函数指针数组将很方便。这样，将可使用for循环通过指针依次调用每个函数。如何声明这样的数组呢？显然，这种声明应类似于单个函数指针的声明，但必须在某个地方加上[3]，以指出这是一个包含三个函数指针的数组。问题是在什么地方加上[3]，答案如下（包含初始化）：
```
const double * (*pa[3]) (const double *, int) = {f1,f2,f3};
```
为何将[3]放在这个地方呢？pa是一个包含三个元素的数组，而要声明这样的数组，首先需要使用pa[3]。该声明的其他部分指出了数组包含的元素是什么样的。运算符[] 的优先级高于*，因此*pa[3]表明pa是一个包含三个指针的数组。上述声明的其他部分指出了每个指针指向的是什么：特征标为const double *, int，且返回类型为const double *的函数。因此，pa是一个包含三个指针的数组，其中每个指针都指向这样的函数，即将const double *和int作为参数，并返回一个const double *。

这里能否使用auto呢？不能。自动类型推断只能用于单值初始化，而不能用于初始化列表。但声明数组pa后，声明同样类型的数组就很简单了：

如何使用它们来调用函数呢？pa[i]和pb[i]都表示数组中的指针，因此可将任何一种函数调用表示法用于它们：

可做的另一件事是创建指向整个数组的指针。由于数组名pa是指向函数指针的指针，因此指向数组的指针将是这样的指针，即它指向指针的指针。这听起来令人恐怖，但由于可使用单个值对其进行初始化，因此可使用auto：
```
auto pc = &pa;
```
如果这个指针名为pd，则需要指出它是一个指针，而不是数组。这意味着声明的核心部分应为(* pd)[3]，其中的括号让标识符pd与*先结合：
```
*pd[3]      //an array of 3 pointers
(*pd)[3]    //a pointer to an array of 3 elements
```
pd是一个指针，它指向一个包含三个元素的数组。这些元素是什么呢？
```
const double *(*(*pd)[3])(const double *, int) = &pa;
```
要调用函数，需认识到这样一点：既然pd指向数组，那么* pd就是数组，而(*pd)[i]是数组中的元素，即函数指针。

请注意pa（它是数组名，表示地址）和&pa之间的差别。正如您在本书前面看到的，在大多数情况下，pa都是数组第一个元素的地址，即&pa[0]。因此，它是单个指针的地址。但&pa是整个数组（即三个指针块）的地址。从数字上说，pa和&pa的值相同，但它们的类型不同。一种差别是，pa+1为数组中下一个元素的地址，而&pa+1为数组pa后面一个12字节内存块的地址（这里假定地址为4字节）。另一个差别是，要得到第一个元素的值，只需对pa解除一次引用，但需要对&pa解除两次引用
### 7.10.4 使用typedef进行简化
```
typedef const double *(*p_fun)(const double *,int);
p_fun p1 = f1;
```
## 7.11 总结
1. 函数是C++的编程模块。要使用函数，必须提供定义和原型，并调用该函数。函数定义是实现函数功能的代码；函数原型描述了函数的接口：传递给函数的值的数目和种类以及函数的返回类型。函数调用使得程序将参数传递给函数，并执行函数的代码。
2. 在默认情况下，C++函数按值传递参数。这意味着函数定义中的形参是新的变量，它们被初始化为函数调用所提供的值。因此，C++函数通过使用拷贝，保护了原始数据的完整性。
3. C++将数组名参数视为数组第一个元素的地址。从技术上讲，这仍然是按值传递的，因为指针是原始地址的拷贝，但函数将使用指针来访问原始数组的内容。当且仅当声明函数的形参时，下面两个声明才是等价的：
```
typeName arr[];
typeName *arr;
```
这两个声明都表明，arr是指向typeName的指针，但在编写函数代码时，可以像使用数组名那样使用arr来访问元素：arr[i]。即使在传递指针时，也可以将形参声明为const指针，来保护原始数据的完整性。由于传递数据的地址时，并不会传输有关数组长度的信息，因此通常将数组长度作为独立的参数来传递。另外，也可传递两个指针（其中一个指向数组开头，另一个指向数组末尾的下一个元素），以指定一个范围，就像STL使用的算法一样。

4. C++提供了3种表示C-风格字符串的方法：字符数组、字符串常量和字符串指针。它们的类型都是char*（char指针），因此被作为char*类型参数传递给函数。C++使用空值字符（\0）来结束字符串，因此字符串函数检测空值字符来确定字符串的结尾。
5. C++还提供了string类，用于表示字符串。函数可以接受string对象作为参数以及将string对象作为返回值。string类的方法size( )可用于判断其存储的字符串的长度。
6. C++处理结构的方式与基本类型完全相同，这意味着可以按值传递结构，并将其用作函数返回类型。然而，如果结构非常大，则传递结构指针的效率将更高，同时函数能够使用原始数据。这些考虑因素也适用于类对象。
7. C++函数可以是递归的，也就是说，函数代码中可以包括对函数本身的调用。
8. C++函数名与函数地址的作用相同。通过将函数指针作为参数，可以传递要调用的函数的名称。