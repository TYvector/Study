# 第7章 函数——C++的编程模块
## 7.1 复习函数的基本知识
要使用C++函数，必须：
- 提供函数定义；
- 提供函数原型；
- 调用函数。

库函数是已经定义和编译好的函数，同时可以使用标准库头文件提供其原型，因此只需正确地调用这种函数即可。
### 7.1.1 定义函数
可以将函数分成两类：没有返回值的函数和有返回值的函数。没有返回值的函数被称为void函数，其通用格式如下：
```
void functionName(parameterList)
{
    statement(s)
    return;             //optional
}
```
parameterList指定了传递给函数的参数类型和数量。可选的返回语句标记了函数的结尾；否则，函数将在右花括号处结束。通常，可以用void函数来执行某种操作。

有返回值的函数将生成一个值，并将它返回给调用函数。这种函数的类型被声明为返回值的类型，其通用格式如下：
```
typeName functionName(parameterList)
{
    statements
    return value;
}
```
对于有返回值的函数，必须使用返回语句，以便将值返回给调用函数。值本身可以是常量、变量，也可以是表达式，只是其结果的类型必须为typeName类型或可以被转换为typeName。C++对于返回值的类型有一定的限制：不能是数组，但可以是其他任何类型——整数、浮点数、指针，甚至可以是结构和对象！

通常，函数通过将返回值复制到指定的CPU寄存器或内存单元中来将其返回。随后，调用程序将查看该内存单元。返回函数和调用函数必须就该内存单元中存储的数据的类型达成一致。函数原型将返回值类型告知调用程序，而函数定义命令被调用函数应返回什么类型的数据。

函数在执行返回语句后结束。如果函数包含多条返回语句（例如，它们位于不同的if else选项中），则函数在执行遇到的第一条返回语句后结束。

### 7.1.2 函数原型和函数调用
#### 1.为什么需要原型
原型描述了函数到编译器的接口，也就是说，它将函数返回值的类型（如果有的话）以及参数的类型和数量告诉编译器。
```
double volume = cube(side);
```
首先，原型告诉编译器，cube( )有一个double参数。如果程序没有提供这样的参数，原型将让编译器能够捕获这种错误。其次，cube( )函数完成计算后，将把返回值放置在指定的位置——可能是CPU寄存器，也可能是内存中。然后调用函数（这里为main( )）将从这个位置取得返回值。由于原型指出了cube( )的类型为double，因此编译器知道应检索多少个字节以及如何解释它们。
#### 2.原型的语法
函数原型是一条语句，因此必须以分号结束。获得原型最简单的方法是，复制函数定义中的函数头，并添加分号。
```
double cube(double x);
void cheers(int);
```
通常，在原型的参数列表中，可以包括变量名，也可以不包括。原型中的变量名相当于占位符，因此不必与函数定义中的变量名相同。

在C++中，不指定参数列表时应使用省略号：
```
void say_bye(...);
```
#### 3.原型的功能
- 编译器正确处理函数返回值；
- 编译器检查使用的参数数目是否正确；
- 编译器检查使用的参数类型是否正确。如果不正确，则转换为正确的类型（如果可能的话）。

仅当有意义时，原型化才会导致类型转换。例如，原型不会将整数转换为结构或指针。

在编译阶段进行的原型化被称为静态类型检查（static type checking）。可以看出，静态类型检查可捕获许多在运行阶段非常难以捕获的错误。
## 7.2 函数参数和按值传递
C++通常按值传递参数，这意味着将数值参数传递给函数，而后者将其赋给一个新的变量。
```
double volume = cube(side);

double cube(double x)
```
被调用时，该函数将创建一个新的名为x的double变量，并将其初始化为5。这样，cube( )执行的操作将不会影响main( )中的数据，因为cube( )使用的是side的副本，而不是原来的数据。用于接收传递值的变量被称为形参。传递给函数的值被称为实参。出于简化的目的，C++标准使用参数（argument）来表示实参，使用参量（parameter）来表示形参，因此参数传递将参量赋给参数。

在函数中声明的变量（包括参数）是该函数私有的。在函数被调用时，计算机将为这些变量分配内存；在函数结束时，计算机将释放这些变量使用的内存。这样的变量被称为局部变量，这样的变量也被称为自动变量，因为它们是在程序执行过程中自动被分配和释放的。
### 7.2.1 多个参数
函数可以有多个参数。在调用函数时，只需使用逗号将这些参数分开即可。同样，在定义函数时，也在函数头中使用由逗号分隔的参数声明列表。如果函数的两个参数的类型相同，则必须分别指定每个参数的类型，而不能像声明常规变量那样，将声明组合在一起。和一个参数的情况一样，原型中的变量名不必与定义中的变量名相同，而且可以省略。
### 7.2.2 另外一个接受两个参数的函数
## 7.3 函数和数组
```
int sum_arr(int arr[], int n)
```
arr实际上并不是数组，而是一个指针！在编写函数的其余部分时，可以将arr看作是数组。
### 7.3.1 函数如何使用指针来处理数组
C++将数组名解释为其第一个元素的地址。

该规则有一些例外。首先，数组声明使用数组名来标记存储位置；其次，对数组名使用sizeof将得到整个数组的长度（以字节为单位）；第三，将地址运算符&用于数组名时，将返回整个数组的地址。
```
int sum_arr(int * arr ,int n)
```
其中用int * arr替换了int arr [ ]。这证明这两个函数头都是正确的，因为在C++中，当（且仅当）用于函数头或函数原型中，int *arr和int arr[ ]的含义才是相同的。它们都意味着arr是一个int指针。然而，数组表示法（int arr[ ]）提醒用户，arr不仅指向int，还指向**int数组的第一个int**。当指针指向**数组的第一个元素**时，本书使用数组表示法；而当指针指向**一个独立的值**时，使用指针表示法。
```
arr[i] = *(ar + i)
&arr[i] = ar + i
```
将指针（包括数组名）加1，实际上是加上了一个与指针指向的类型的长度（以字节为单位）相等的值。
### 7.3.2 将数组作为参数意味着什么
程序实际上并没有将数组内容传递给函数，而是将数组的位置（地址）、包含的元素种类（类型）以及元素数目（n变量）提交给函数。有了这些信息后，函数便可以使用原来的数组。传递常规变量时，函数将使用该变量的拷贝；但传递数组时，函数将使用原来的数组。

数组名与指针对应是好事吗？确实是一件好事。将数组地址作为参数可以节省复制整个数组所需的时间和内存。如果数组很大，则使用拷贝的系统开销将非常大；程序不仅需要更多的计算机内存，还需要花费时间来复制大块的数据。另一方面，使用原始数据增加了破坏数据的风险。ANSI C和C++中的const限定符提供了解决这种问题的办法。

指针本身并没有指出数组的长度。

为将数组类型和元素数量告诉数组处理函数，请通过两个不同的参数来传递它们，而不要试图使用方括号表示法来传递数组长度：
```
void fillArray(int arr[] , int size);

void fillArray(int arr[size]);
```
### 7.3.3 更多数组函数示例
#### 显示数组及用const保护数组
为防止函数无意中修改数组的内容，可在声明形参时使用关键字const
```
void show_array(const double ar[], int n);
```
这并不是意味着原始数组必须是常量，而只是意味着不能在show_array( )函数中使用ar来修改这些数据。因此，show_array( )将数组视为只读数据。

**自下而上的程序设计（bottom-up programming）**，因为设计过程从组件到整体进行。这种方法非常适合于OOP——它首先强调的是数据表示和操纵。而传统的过程性编程倾向于**从上而下的程序设计（top-down programming**）**，首先指定模块化设计方案，然后再研究细节。
#### 数组处理函数的常用编写方式
```
void f_modify(double ar[], int n);              //修改数组
void _f_no_change(const double ar[], int n);    //不修改数组
```
ar实际上是一个指针，指向传入的数组的第一个元素；另外，由于通过参数传递了元素数，这两个函数都可使用任何长度的数组。函数缺少一些有关原始数组的知识；例如，它不能使用sizeof来获悉原始数组的长度。
### 7.3.4 使用数组区间的函数
还有另一种给函数提供所需信息的方法，即指定元素区间（range），这可以通过传递两个指针来完成：一个指针标识数组的开头，另一个指针标识数组的尾部。C++标准模板库（STL，将在第16章介绍）将区间方法广义化了。STL方法使用“超尾”概念来指定区间。也就是说，对于数组而言，标识数组结尾的参数将是指向最后一个元素后面的指针。
### 7.3.5 指针和const
可以用两种不同的方式将const关键字用于指针。第一种方法是让指针指向一个常量对象，这样可以防止使用该指针来修改所指向的值，第二种方法是将指针本身声明为常量，这样可以防止改变指针指向的位置。
```
int age = 39;
const int * pt = &age;
```
该声明指出，pt指向一个const int（这里为39），因此不能使用pt来修改这个值。换句话来说，*pt的值为const，不能被修改。pt的声明并不意味着它指向的值实际上就是一个常量，而只是意味着对pt而言，这个值是常量。例如，pt指向age，而age不是const。可以直接通过age变量来修改age的值，但不能使用pt指针来修改它。

将const变量的地址赋给指向const的指针。C++禁止将const的地址赋给非const指针。

仅当只有一层间接关系（如指针指向基本数据类型）时，才可以将非const地址或指针赋给const指针。

如果数据类型本身并不是指针，则可以将const数据或非const数据的地址赋给指向const的指针，但只能将非const数据的地址赋给非const指针。
```
int sloth = 3;
const int *ps = &sloth;
int * const finger = &sloth;
```
第一个声明只能防止修改指向的值，而不能防止修改ps的值。也就是说，可以将一个新地址赋给ps。第二种使用const的方式使得无法修改指针的值。这种声明格式使得finger只能指向sloth，但允许使用finger来修改sloth的值。中间的声明不允许使用ps来修改sloth的值，但允许将ps指向另一个位置。简而言之，finger和* ps都是const，而*finger和ps不是。

如果愿意，还可以声明指向const对象的const指针

通常，将指针作为函数参数来传递时，可以使用指向const的指针来保护数据。
```
void show_array(const double ar[], int n);
```
在该声明中使用const意味着show_array( )不能修改传递给它的数组中的值。只要只有一层间接关系，就可以使用这种技术。例如，这里的数组元素是基本类型，但如果它们是指针或指向指针的指针，则不能使用const。
## 7.4 函数和二维数组