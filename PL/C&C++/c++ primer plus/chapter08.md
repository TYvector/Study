# 第8章 函数探幽
## 8.1 C++内联函数
内联函数是C++为提高程序运行速度所做的一项改进。常规函数和内联函数之间的主要区别不在于编写方式，而在于C++编译器如何将它们组合到程序中。

编译过程的最终产品是可执行程序——由一组机器语言指令组成。运行程序时，操作系统将这些指令载入到计算机内存中，因此每条指令都有特定的内存地址。计算机随后将逐步执行这些指令。有时（如有循环或分支语句时），将跳过一些指令，向前或向后跳到特定地址。常规函数调用也使程序跳到另一个地址（函数的地址），并在函数结束时返回。下面更详细地介绍这一过程的典型实现。执行到函数调用指令时，程序将在函数调用后立即存储该指令的内存地址，并将函数参数复制到堆栈（为此保留的内存块），跳到标记函数起点的内存单元，执行函数代码（也许还需将返回值放入到寄存器中），然后跳回到地址被保存的指令处（这与阅读文章时停下来看脚注，并在阅读完脚注后返回到以前阅读的地方类似）。来回跳跃并记录跳跃位置意味着以前使用函数时，需要一定的开销。

C++内联函数提供了另一种选择。内联函数的编译代码与其他程序代码“内联”起来了。也就是说，编译器将使用相应的函数代码替换函数调用。对于内联代码，**程序无需跳到另一个位置处执行代码，再跳回来**。因此，**内联函数的运行速度比常规函数稍快**，但代价是需要占用更多内存。如果程序在10个不同的地方调用同一个内联函数，则该程序将包含该函数代码的10个副本。

应有选择地使用内联函数。如果执行函数代码的时间比处理函数调用机制的时间长，则节省的时间将只占整个过程的很小一部分。如果代码执行时间很短，则内联调用就可以节省非内联调用使用的大部分时间。另一方面，由于这个过程相当快，因此尽管节省了该过程的大部分时间，但节省的时间绝对值并不大，除非该函数经常被调用。

要使用这项特性，必须采取下述措施之一：
- 在函数声明前加上关键字inline；
- 在函数定义前加上关键字inline。

通常的做法是省略原型，将整个定义（即函数头和所有函数代码）放在本应提供原型的地方。

程序员请求将函数作为内联函数时，编译器并不一定会满足这种要求。它可能认为该函数过大或注意到函数调用了自己（内联函数不能递归），因此不将其作为内联函数；而有些编译器没有启用或实现这种特性。

注意到整个函数定义都放在一行中，但并不一定非得这样做。然而，如果函数定义占用多行（假定没有使用冗长的标识符），则将其作为内联函数就不太合适。
```
inline double square(double x) {return x*x;}
```
inline工具是C++新增的特性。C语言使用预处理器语句#define来提供宏——内联代码的原始实现。例如，下面是一个计算平方的宏
```
#define SQUARE(X) X*X
```
这并不是通过传递参数实现的，而是通过文本替换来实现的——X是“参数”的符号标记。
## 8.2 引用变量
C++新增了一种复合类型——引用变量。引用是已定义的变量的别名（另一个名称）。通过将引用变量用作参数，函数将使用原始数据，而不是其副本。
### 8.2.1 创建引用变量
前面讲过，C和C++使用&符号来指示变量的地址。C++给&符号赋予了另一个含义，将其用来声明引用。例如，要将rodents作为rats变量的别名，可以这样做：
```
int rat;
int & rodents = rats;
```
其中，&不是地址运算符，而是类型标识符的一部分。就像声明中的char*指的是指向char的指针一样，int &指的是指向int的引用。上述引用声明允许将rats和rodents互换——它们指向相同的值和内存单元。

语句中的&运算符不是地址运算符，而是将rodents的类型声明为int &，即指向int变量的引用。

必须在声明引用时将其初始化。引用更接近const指针，必须在创建时进行初始化，一旦与某个变量关联起来，就将一直效忠于它。

可以通过初始化声明来设置引用，但不能通过赋值来设置。
### 8.2.2 将引用用作函数参数
引用经常被用作函数参数，使得函数中的变量名成为调用程序中的变量的别名。这种传递参数的方法称为按引用传递。按引用传递允许被调用的函数能够访问调用函数中的变量。
```
void swapr(int & a, int & b);   //按引用传递
void swapp(int * p, int * p);   //按指针传递
void swapv(int a, int b);       //按值传递

swapr(wallet1, wallet2);
swapp(&wallet1, &wallet2);
swapv(wallet1, wallet2);
```
引用和指针方法都成功地交换了两个钱夹（wallet）中的内容，而按值传递的方法没能完成这项任务。

在swapr( )中，变量a和b是wallet1和wallet2的别名，所以交换a和b的值相当于交换wallet1和wallet2的值；但在swapv( )中，变量a和b是复制了wallet1和waller2的值的新变量，因此交换a和b的值并不会影响wallet1和wallet2的值。

函数调用将形参a和b分别初始化为wallet1和wallet2
### 8.2.3 引用的属性和特别之处
```
double refcube(double &ra);
```
如果将与上面类似的参数传递给接受引用参数的函数，将会发现，传递引用的限制更严格。毕竟，如果ra是一个变量的别名，则实参应是该变量。下面的代码不合理，因为表达式x + 3.0并不是变量
```
double z = refcube(x + 3.0);
```
如果试图使用像refcube(x + 3.0)这样的函数调用，将发生什么情况呢？在现代的C++中，这是错误的，大多数编译器都将指出这一点；而有些较老的编译器将发出这样的警告：

之所以做出这种比较温和的反应是由于早期的C++确实允许将表达式传递给引用变量。有些情况下，仍然是这样做的。这样做的结果如下：由于x + 3.0不是double类型的变量，因此程序将创建一个临时的无名变量，并将其初始化为表达式x + 3.0的值。然后，ra将成为该临时变量的引用。下面详细讨论这种临时变量，看看什么时候创建它们，什么时候不创建。
#### 临时变量、引用参数和const
如果实参与引用参数不匹配，C++将生成临时变量。当前，仅当参数为const引用时，C++才允许这样做，但以前不是这样。下面来看看何种情况下，C++将生成临时变量，以及为何对const引用的限制是合理的。

如果引用参数是const，则编译器将在下面两种情况下生成临时变量：
- 实参的类型正确，但不是左值；
- 实参的类型不正确，但可以转换为正确的类型。

左值参数是可被引用的数据对象，例如，变量、数组元素、结构成员、引用和解除引用的指针都是左值。非左值包括字面常量（用引号括起的字符串除外，它们由其地址表示）和包含多项的表达式。在C语言中，左值最初指的是可出现在赋值语句左边的实体，但这是引入关键字const之前的情况。现在，常规变量和const变量都可视为左值，因为可通过地址访问它们。但常规变量属于可修改的左值，而const变量属于不可修改的左值。

如果接受引用参数的函数的意图是修改作为参数传递的变量，则创建临时变量将阻止这种意图的实现。解决方法是，禁止创建临时变量，现在的C++标准正是这样做的

现在来看refcube( )函数。该函数的目的只是使用传递的值，而不是修改它们，因此临时变量不会造成任何不利的影响，反而会使函数在可处理的参数种类方面更通用。因此，如果声明将引用指定为const，C++将在必要时生成临时变量。实际上，对于形参为const引用的C++函数，如果实参不匹配，则其行为类似于按值传递，为确保原始数据不被修改，将使用临时变量来存储值。

如果函数调用的参数不是左值或与相应的const引用参数的类型不匹配，则C++将创建类型正确的匿名变量，将函数调用的参数的值传递给该匿名变量，并让参数来引用该变量

将引用参数声明为常量数据的引用的理由有三个：
- 使用const可以避免无意中修改数据的编程错误；
- 使用const使函数能够处理const和非const实参，否则将只能接受非const数据；
- 使用const引用使函数能够正确生成并使用临时变量。


因此，应尽可能将引用形参声明为const。

C++11新增了另一种引用——右值引用（rvalue reference）。这种引用可指向右值，是使用&&声明的：以前的引用（使用&声明的引用）现在称为左值引用。
```
double && rref = std::sqrt(36.00);
double j = 15.0;
double && jref = 2.0* j + 18.5;
```
### 8.2.4 将引用用于结构
引用非常适合用于结构和类。

使用结构引用参数的方式与使用基本变量引用相同，只需在声明结构参数时使用引用运算符&即可。如果不希望函数修改传入的结构，可使用const。
返回引用的函数
```
free_throws & accumulate(free_throw & target, const free_throws & source)
```
如果返回类型被声明为free_throws而不是free_throws &，上述返回语句将返回target的拷贝。但返回类型为引用，这意味着返回的是最初传递给accumulate()的target对象。

```
accumulate(dup, five) = four;
```
这条语句将值赋给函数调用，这是可行的，因为函数的返回值是一个引用。如果函数accumulate()按值返回，这条语句将不能通过编译。由于返回的是指向dup的引用，因此上述代码与下面的代码等效：
```
accumulate(dup,five);
dup = four;
```
#### 为何要返回引用
传统返回机制与按值传递函数参数类似：计算关键字return后面的表达式，并将结果返回给调用函数。从概念上说，这个值被复制到一个临时位置，而调用程序将使用这个值。

返回引用的函数实际上是被引用的变量的别名。

返回引用时最重要的一点是，应避免返回函数终止时不再存在的内存单元引用。
```
const free_throws & clone2(free_throws &ft)
{
    free_throws newguy;
    newguy = ft;
    return newguy;
}
```
该函数返回一个指向临时变量（newguy）的引用，函数运行完毕后它将不再存在。同样，也应避免返回指向临时变量的指针。

为避免这种问题，最简单的方法是，返回一个作为参数传递给函数的引用。作为参数的引用将指向调用函数使用的数据，因此返回的引用也将指向这些数据。

另一种方法是用new来分配新的存储空间。前面见过这样的函数，它使用new为字符串分配内存空间，并返回指向该内存空间的指针。下面是使用引用来完成类似工作的方法：
```
const free_throws & clone (free_throws & ft)
{
    free_throws * pt;
    *pt = ft;
    return *pt;
}
```
第一条语句创建一个无名的free_throws结构，并让指针pt指向该结构，因此*pt就是该结构。上述代码似乎会返回该结构，但函数声明表明，该函数实际上将返回这个结构的引用。这样，便可以这样使用该函数：
```
free_throws & jolly = clone(three);
```
这使得jolly成为新结构的引用。这种方法存在一个问题：在不再需要new分配的内存时，应使用delete来释放它们。调用clone( )隐藏了对new的调用，这使得以后很容易忘记使用delete来释放内存。
#### 为何将const用于引用返回类型
```
accumulate(dup,five) = four;
```
首先将five的数据添加到dup中，再使用four的内容覆盖dup的内容。这条语句为何能够通过编译呢？在赋值语句中，左边必须是可修改的左值。也就是说，在赋值表达式中，左边的子表达式必须标识一个可修改的内存块。在这里，函数返回指向dup的引用，它确实标识的是一个这样的内存块，因此这条语句是合法的。

另一方面，常规（非引用）返回类型是右值——不能通过地址访问的值。这种表达式可出现在赋值语句的右边，但不能出现在左边。但为何常规函数返回值是右值呢？这是因为这种返回值位于临时内存单元中，运行到下一条语句时，它们可能不再存在。

假设您要使用引用返回值，但又不允许执行像给accumulate()赋值这样的操作，只需将返回类型声明为const引用：

```
const free_throws & accumulate(free_throw & target, const free_throws & source);
```
现在返回类型为const，是不可修改的左值，因此下面的赋值语句不合法：
```
accumulate(dup,five) = four;
```
### 8.2.5 将引用用于类对象
将类对象传递给函数时，C++通常的做法是使用引用。
```
string version1(const string & s1, const string & s2)
{
    string temp;

    temp = s2 + s1 + s2;
    return temp;
}
```
它接受两个string参数，并使用string类的相加功能来创建一个满足要求的新字符串。这两个函数参数都是const引用。如果使用string对象作为参数，最终结果将不变：
```
string version4(string s1, string s2)
```
使用引用的效率更高，因为函数不需要创建新的string对象，并将原来对象中的数据复制到新对象
中。限定符const指出，该函数将使用原来的string对象，但不会修改它。

temp是一个新的string对象，只在函数version1( )中有效，该函数执行完毕后，它将不再存在。因此，返回指向temp的引用不可行，因此该函数的返回类型为string，这意味着temp的内容将被复制到一个临时存储单元中，然后在main( )中，该存储单元的内容被复制到一个名为result的string中：
```
result = version1(input, "***");
```
可以将实参char *或const char *传递给形参const string &。这种属性的结果是，如果形参类型为const string &，在调用函数时，使用的实参可以是string对象或C-风格字符串，如用引号括起的字符串字面量、以空字符结尾的char数组或指向char的指针变量。
```
const string & version2(string & s1, const string & s2)
{
    s1 = s2 + s1 + s2;

    return s1;
}
```
函数version2( )不创建临时string对象，而是直接修改原来的string对象，该函数可以修改s1，因为不同于s2，s1没有被声明为const。

由于s1是指向main( )中一个对象（input）的引用，因此将s1最为引用返回是安全的。

```
const string & version3(string & s1, const string & s2)
{
    string temp;

    temp = s2 + s1 + s2;

    return temp;
}
```
它存在一个致命的缺陷：返回一个指向version3( )中声明的变量的引用。这个函数能够通过编译（但编译器会发出警告），但当程序试图执行该函数时将崩溃。程序试图引用已经释放的内存。
### 8.2.6 对象、继承和引用
ostream和ofstream类凸现了引用的一个有趣属性。ofstream对象可以使用ostream类的方法，这使得文件输入/输出的格式与控制台输入/输出相同。使得能够将特性从一个类传递给另一个类的语言特性被称为继承，简单地说，ostream是**基类**（因为ofstream是建立在它的基础之上的），而ofstream是**派生类**（因为它是从ostream派生而来的）。派生类继承了基类的方法，这意味着ofstream对象可以使用基类的特性，如格式化方法precision( )和setf()。

继承的另一个特征是，基类引用可以指向派生类对象，而无需进行强制类型转换。这种特征的一个实际结果是，可以定义一个接受基类引用作为参数的函数，调用该函数时，可以将基类对象作为参数，也可以将派生类对象作为参数。

方法setf( )让您能够设置各种格式化状态。例如，方法调用setf(ios_base::fixed)将对象置于使用定点表示法的模式；setf(ios_base::showpoint)将对象置于显示小数点的模式，即使小数部分为零。方法precision( )指定显示多少位小数（假定对象处于定点模式下）。所有这些设置都将一直保持不变，直到再次调用相应的方法重新设置它们。方法width( )设置下一次输出操作使用的字段宽度，这种设置只在显示下一个值时有效，然后将恢复到默认设置。默认的字段宽度为零，这意味着刚好能容纳下要显示的内容。

方法setf( )返回调用它之前有效的所有格式化设置。

### 8.2.7 何时使用引用参数
- 程序员能够修改调用函数中的数据对象。
- 通过传递引用而不是整个数据对象，可以提高程序的运行速度。

当数据对象较大时（如结构和类对象），第二个原因最重要。这些也是使用指针参数的原因。这是有道理的，因为引用参数实际上是基于指针的代码的另一个接口。

对于使用传递的值而不作修改的函数

- 如果数据对象很小，如内置数据类型或小型结构，则按值传递。
- 如果数据对象是数组，则使用指针，因为这是唯一的选择，并将指针声明为指向const的指针。
- 如果数据对象是较大的结构，则使用const指针或const引用，以提高程序的效率。这样可以节省复制结构所需的时间和空间。
- 如果数据对象是类对象，则使用const引用。类设计的语义常常要求使用引用，这是C++新增这项特性的主要原因。因此，传递类对象参数的标准方式是按引用传递。

对于修改调用函数中数据的函数：

- 如果数据对象是内置数据类型，则使用指针。如果看到诸如fixit（&x）这样的代码（其中x是int），则很明显，该函数将修改x。
- 如果数据对象是数组，则只能使用指针。
- 如果数据对象是结构，则使用引用或指针。
- 如果数据对象是类对象，则使用引用。

## 8.3 默认参数
默认参数指的是当函数调用中省略了实参时自动使用的一个值。如何设置默认值呢？必须通过函数原型。由于编译器通过查看原型来了解函数所使用的参数数目，因此函数原型也必须将可能的默认参数告知程序。方法是将值赋给原型中的参数。
```
char * left(const char * str, int n = 1);
```
您希望该函数返回一个新的字符串，因此将其类型设置为char*（指向char的指针）；您希望原始字符串保持不变，因此对第一个参数使用了const限定符；您希望n的默认值为1，因此将这个值赋给n。默认参数值是初始化值，因此上面的原型将n初始化为1。如果省略参数n，则它的值将为1；否则，传递的值将覆盖1。

对于带参数列表的函数，必须从右向左添加默认值。也就是说，要为某个参数设置默认值，则必须为它右边的所有参数提供默认值：
```
int harpo(int n, int m = 4, int j = 5); //VALID
int chico(int n, int m = 6, int j);     //INVALID
```

实参按从左到右的顺序依次被赋给相应的形参，而不能跳过任何参数。

请注意，只有原型指定了默认值。函数定义与没有默认参数时完全相同。
## 8.4 函数重载
函数多态是C++在C语言的基础上新增的功能。默认参数让您能够使用不同数目的参数调用同一个函数，而函数多态（函数重载）让您能够使用多个同名的函数。术语“多态”指的是有多种形式，因此函数多态允许函数可以有多种形式。类似地，术语“函数重载”指的是可以有多个同名的函数，因此对名称进行了重载。

函数重载的关键是函数的参数列表——也称为函数特征标（function signature）。如果两个函数的参数数目和类型相同，同时参数的排列顺序也相同，则它们的特征标相同，而变量名是无关紧要的。C++允许定义名称相同的函数，条件是它们的特征标不同。如果参数数目和/或参数类型不同，则特征标也不同。
```
void print(const char * str, int width);
void print(double d, int width);
void print(long l, int width);
void print(int i, int width);
void print(const char * str);
```
使用被重载的函数时，需要在函数调用中使用正确的参数类型。

一些看起来彼此不同的特征标是不能共存的。
```
double cube(double x);
double cube(double & x);
```
为避免这种混乱，编译器在检查函数特征标时，将把类型引用和类型本身视为同一个特征标。

匹配函数时，并不区分const和非const变量。
```
void dribble(char * bits);
void dribble(const char * cbits);
void dabble(char * bits);
void drivel(const char * bits);
```
dribble( )函数有两个原型，一个用于const指针，另一个用于常规指针，编译器将根据实参是否为const来决定使用哪个原型。dribble( )函数只与带非const参数的调用匹配，而drivel( )函数可以与带const或非const参数的调用匹配。drivel( )和dabble( )之所以在行为上有这种差别，主要是由于将非const值赋给const变量是合法的，但反之则是非法的。

请记住，是特征标，而不是函数类型使得可以对函数进行重载。例如，下面的两个声明是互斥的：
```
long gronk(int n, float m);
double gronk(int n, float m);
```
C++不允许以这种方式重载gronk( )。返回类型可以不同，但特征标也必须不同：
```
long gronk(int n, float m);
double gronk(float n, float m);
```
### 8.4.1 重载示例
### 8.4.2 何时使用函数重载
仅当函数基本上执行相同的任务，但使用不同形式的数据时，才应采用函数重载。
#### 什么是名称修饰
C++如何跟踪每一个重载函数呢？它给这些函数指定了秘密身份。使用C++开发工具中的编辑器编写和编译程序时，C++编译器将执行一些神奇的操作——名称修饰（namedecoration）或名称矫正（name mangling），它根据函数原型中指定的形参类型对每个函数名进行加密。
## 8.5 函数模板
函数模板是通用的函数描述，也就是说，它们使用泛型来定义函数，其中的泛型可用具体的类型（如int或double）替换。通过将类型作为参数传递给模板，可使编译器生成该类型的函数。由于模板允许以泛型（而不是具体类型）的方式编写程序，因此有时也被称为通用编程。由于类型是用参数表示的，因此模板特性有时也被称为参数化类型（parameterized types）。下面介绍为何需要这种特性以及其工作原理。

函数模板允许以任意类型的方式来定义函数。例如，可以这样建立一个交换模板：
```
template <typename AnyType>
void Swap(AnyType &a, AnyType &b)
{
    AnyType temp;
    temp = a;
    a = b;
    b = temp;
}
```
第一行指出，要建立一个模板，并将类型命名为AnyType。关键字template和typename是必需的，除非可以使用关键字class代替typename。另外，必须使用尖括号。类型名可以任意选择（这里为AnyType），只要遵守C++命名规则即可；
模板并不创建任何函数，而只是告诉编译器如何定义函数。需要交换int的函数时，编译器将按模板模式创建这样的函数，并用int代替AnyType。
在标准C++98添加关键字typename之前，C++使用关键字class来创建模板。
```
template <class AnyType>
```
要让编译器知道程序需要一个特定形式的交换函数，只需在程序中使用Swap( )函数即可。编译器将检查所使用的参数类型，并生成相应的函数。
### 8.5.1 重载的模板
并非所有的类型都使用相同的算法。为满足这种需求，可以像重载常规函数定义那样重载模板定义。和常规重载一样，被重载的模板的函数特征标必须不同。并非所有的模板参数都必须是模板参数类型。
```
template <typename T>
void Swap(T &a, T &b);

template <typename T>
void Swap(T *a, T *b, int n);
```
### 8.5.2 模板的局限性
通常，代码假定可执行哪些操作。例如，下面的代码假定定义了赋值，但如果T为数组，这种假设将不成立：
```
a = b;
```
总之，编写的模板函数很可能无法处理某些类型。一种解决方案是，C++允许您重载运算符+，以便能够将其用于特定的结构或类（运算符重载将在第11章讨论）。这样使用运算符+的模板便可处理重载了运算符+的结构。另一种解决方案是，为特定类型提供具体化的模板定义，下面就来介绍这种解决方案。
### 8.5.3 显式具体化
```
struct job
{
    char name[40];
    double salary;
    int floor;
}
```
假设只想交换salary和floor成员，而不交换name成员，则需要使用不同的代码，但Swap( )的参数将保持不变（两个job结构的引用），因此无法使用模板重载来提供其他的代码。可以提供一个具体化函数定义——称为显式具体化（explicitspecialization），其中包含所需的代码。当编译器找到与函数调用匹配的具体化定义时，将使用该定义，而不再寻找模板。
#### 第三代具体化（ISO/ANSI C++标准）
- 对于给定的函数名，可以有非模板函数、模板函数和显式具体化模板函数以及它们的重载版本。
- 显式具体化的原型和定义应以template<>打头，并通过名称来指出类型。
- 具体化优先于常规模板，而非模板函数优先于具体化和常规模板。

```
// non template function prototype
void Swap(job &, job &);

// template prototype
template <typename T>
void Swap(T &, T &);

//explicit specialization for the job type
template <> void Swap<job>(job &, job &);
```
如果有多个原型，则编译器在选择原型时，非模板版本优先于显式具体化和模板版本，而显式具体化优先于使用模板生成的版本。

Swap< job >中的< job >是可选的，因为函数的参数类型表明，这是job的一个具体化。因此，该原型也可以这样编写：
```
template <> void Swap(job &, job &);
```
### 8.5.4 实例化和具体化
为进一步了解模板，必须理解术语实例化和具体化。记住，在代码中包含函数模板本身并不会生成函数定义，它只是一个用于生成函数定义的方案。编译器使用模板为特定类型生成函数定义时，得到的是**模板实例（instantiation）**。函数调用Swap(i, j)导致编译器生成Swap( )的一个实例，该实例使用int类型。模板并非函数定义，但使用int的模板实例是函数定义。这种实例化方式被称为**隐式实例化（implicit instantiation）**，因为编译器之所以知道需要进行定义，是由于程序调用Swap( )函数时提供了int参数。

最初，编译器只能通过隐式实例化，来使用模板生成函数定义，但现在C++还允许**显式实例化（explicit instantiation）**。这意味着可以直接命令编译器创建特定的实例，如Swap< int >( )。其语法是，声明所需的种类——用<>符号指示类型，并在声明前加上关键字template：
```
template void Swap<int>(int, int);
```
实现了这种特性的编译器看到上述声明后，将使用Swap( )模板生成一个使用int类型的实例。也就是说，该声明的意思是“使用Swap( )模板生成int类型的函数定义。”

与显式实例化不同的是，显式具体化使用下面两个等价的声明之一
```
template <> void Swap<int>(int &, int &);
template <> void Swap(int &, int &);
```
区别在于，这些声明的意思是“不要使用Swap( )模板来生成函数定义，而应使用专门为int类型显式地定义的函数定义”。这些原型必须有自己的函数定义。显式具体化声明在关键字template后包含<>，而显式实例化没有。

试图在同一个文件（或转换单元）中使用同一种类型的显式实例和显式具体化将出错。

隐式实例化、显式实例化和显式具体化统称为**具体化（specialization）**。它们的相同之处在于，它们表示的都是使用具体类型的函数定义，而不是通用描述。

引入显式实例化后，必须使用新的语法——在声明中使用前缀template和template <>，以区分显式实例化和显式具体化。
### 8.5.5 编译器选择使用哪个函数版本
对于函数重载、函数模板和函数模板重载，C++需要（且有）一个定义良好的策略，来决定为函数调用使用哪一个函数定义，尤其是有多个参数时。这个过程称为**重载解析（overloading resolution）**。
- 第1步：创建候选函数列表。其中包含与被调用函数的名称相同的函数和模板函数。
- 第2步：使用候选函数列表创建可行函数列表。这些都是参数数目正确的函数，为此有一个隐式转换序列，其中包括实参类型与相应的形参类型完全匹配的情况。例如，使用float参数的函数调用可以将该参数转换为double，从而与double形参匹配，而模板可以为float生成一个实例。
- 第3步：确定是否有最佳的可行函数。如果有，则使用它，否则该函数调用出错。

从最佳到最差的顺序如下所述。
1. 完全匹配，但常规函数优先于模板。
2. 提升转换（例如，char和shorts自动转换为int，float自动转换为double）。
3. 标准转换（例如，int转换为char，long转换为double）。
4. 用户定义的转换，如类声明中定义的转换。

#### 完全匹配和最佳匹配
进行完全匹配时，C++允许某些“无关紧要的转换”。例如，int实参与int &形参完全匹配。Type可以是char &这样的类型，因此这些规则包括从char &到constchar &的转换。Type（argument-list）意味着用作实参的函数名与用作形参的函数指针只要返回类型和参数列表相同，就是匹配的

从实参|到形参
---|:--:
Type|Type &