# 第3章 处理数据
面向对象编程（OOP）的本质是设计并扩展自己的数据类型。设计自己的数据类型就是让类型与数据匹配。
内置的C++类型分两组：基本类型和复合类型。本章将介绍基本类型，即整数和浮点数。
存储数据、使用变量、类型转换。
## 3.1 简单变量
程序必须记录3个基本属性：
- 信息将存储在哪里；
- 要存储什么值；
- 存储何种类型的信息。
### 3.1.1 变量名
必须遵循几种简单的C++命名规则。
- 在名称中只能使用字母字符、数字和下划线（_）。
- 名称的第一个字符不能是数字。
- 区分大写字符与小写字符。
- 不能将C++关键字用作名称。
- 以两个下划线或下划线和大写字母打头的名称被保留给实现（编译器及其使用的资源）使用。以一个下划线开头的名称被保留给实现，用作全局标识符。
- C++对于名称的长度没有限制，名称中所有的字符都有意义，但有些平台有长度限制。
倒数第二点与前面几点有些不同，因为使用像_time_stop或_Donut这样的名称不会导致编译器错误，而会导致行为的不确定性。全局名称指的是名称被声明的位置。
> 在ANSI C中，前63个字符相同的名称被认为是相同的，即使第64个字符不同
如果想用两个或更多的单词组成一个名称，通常的做法是用下划线字符将单词分开，如my_onions；或者从第二个单词开始将每个单词的第一个字母大写，如myEyeTooth。
### 3.1.2 整型
整数就是没有小数部分的数字。不同C++整型使用不同的内存量来存储整数。
C++的基本整型（按宽度递增的顺序排列）分别是char、short、int、long和C++11新增的long long，其中每种类型都有符号版本和无符号版本，因此总共有10种类型。
### 3.1.3 整型short、int、long和long long
C++的short、int、long和long long类型通过使用不同数目的位来存储值。C++提供了一种灵活的标准：
- short至少16位；
- int至少与short一样长；
- long至少32位，且至少与int一样长；
- long long至少64位，且至少与long一样长。
这4种类型（int、short、long和long long）都是符号类型，这意味着每种类型的取值范围中，负值和正值几乎相同。例如，16位的int的取值范围为-32768到+32767。
#### 1.运算符sizeof和头文件limits
**sizeof**运算符返回类型或变量的长度，单位为字节。头文件climits（在老式实现中为limits.h）中包含了关于整型限制的信息。
对类型名（如int）使用sizeof运算符时，应将名称放在括号中；但对变量名（如n_short）使用该运算符，括号是可选的
> #define和#include一样，也是一个预处理器编译指令。C++有一种更好的创建符号常量的方法（使用关键字const，将在后面的一节讨论），所以不会经常使用#define。
#### 2.初始化
初始化将赋值与声明合并在一起。
```
int uncles = 5;
int aunts = uncles;
int chairs = aunts + uncles + 4;
```
C++还有另一种C语言没有的初始化语法：

`int wrens(432);`
#### 3.C++11初始化方式
还有另一种初始化方式，这种方式用于数组和结构，但在C++98中，也可用于单值变量：采用这种方式时，可以使用等号（=），也可以不使用：大括号内可以不包含任何东西。在这种情况下，变量将被初始化为零：
```
int emus{7};
int rheas = {12};
int rocs = {};
int psychics{};
```
这有助于更好地防范类型转换错误
通过使用C++新增的大括号初始化器，初始化常规变量的方式与初始化类变量的方式更像。
### 3.1.4 无符号类型
前面介绍的4种整型都有一种不能存储负数值的无符号变体，其优点是可以增大变量能够存储的最大值。只需使用关键字unsigned来修改声明即可：
```
unsigned short change;
unsigned int rovert;
unsigned quarterback;
unsigned long gone;
unsigned long long lang_lang;
```
unsigned本身是unsigned int的缩写。
C++并不保证符号整型超越限制（上溢和下溢）时不出错
### 3.1.5 选择整型类型
**自然长度**（natural size）指的是计算机处理起来效率最高的长度。如果没有非常有说服力的理由来选择其他类型，则应使用int。
仅当有大型整型数组时，才有必要使用short。如果节省内存很重要，则应使用short而不是使用int，即使它们的长度是一样的。如果只需要一个字节，可使用char
### 3.1.6 整型字面值
C++能够以三种不同的计数方式来书写整数：基数为10、基数为8（老式UNIX版本）和基数为16（硬件黑客的最爱）。C++使用前一（两）位来标识数字常量的基数。
- 如果第一位为1～9，则基数为10（十进制）
- 如果第一位是0，第二位为1～7，则基数为8（八进制）
- 如果前两位为0x或0X，则基数为16（十六进制）；对于十六进制数，字符a～f和A～F表示了十六进制位
在默认情况下，cout以十进制格式显示整数
不管把值书写为10、012还是0xA，都将以相同的方式存储在计算机中—被存储为二进制数（以2为基数）。如果要以十六进制或八进制方式显示值，则可以使用cout的一些特殊特性。提供了控制符dec、hex和oct，分别用于指示cout以十进制、十六进制和八进制格式显示整数。

`cout << hex`

代码不会在屏幕上显示任何内容，而只是修改cout显示整数的方式。控制符hex实际上是一条消息，告诉cout采
取何种行为。另外，由于标识符hex位于名称空间std中，而程序使用了该名称空间，因此不能将hex用作变量名。然而，如果省略编译指令using，而使用std::cout、std::endl、std::hex和std::oct，则可以将hex用作变量名。
### 3.1.7 C++如何确定常量的类型
除非有理由存储为其他类型（如使用了特殊的后缀来表示特定的类型，或者值太大，不能存储为int），否则C++将整型常量存储为int类型。
整数后面的l或L后缀表示该整数为long常量，u或U后缀表示unsigned int常量，ul（可以采用任何一种顺序，大写小写均可）表示unsigned long常量（由于小写l看上去像1，因此应使用大写L作后缀）。
十六进制数0x9C40（40000）将被表示为unsigned int。
### 3.1.8 char类型：字符和小整数
char类型是另一种整型。是专为存储字符（如字母和数字）而设计的。
字符集中的字符用数值编码（ASCII码）表示。
输入时，cin将键盘输入的M转换为77；输出时，cout将值77转换为所显示的字符M；
C++对字符用单引号，对字符串使用双引号。
由于ch实际上是一个整数，因此可以对它使用整数操作，
#### 成员函数cout.put( )
**成员函数**归类所有，描述了操纵类数据的方法。
例如类ostream有一个put( )成员函数，用来输出字符。只能通过类的特定对象（例如这里的cout对象）来使用成员函数。要通过对象（如cout）使用成员函数，必须用句点将对象名和函数名称（put( )）连接起来。句点被称为成员运算符。cout.put( )的意思是，通过类对象cout来使用函数put( )。
在C++的Release 2.0之前，cout将字符变量显示为字符，而将字符常量（如‘M’和‘N’）显示为数字。
#### char字面值
转义序列，\a表示振铃字符，它可以使终端扬声器振铃。转义序列n\表示换行符，\”将双引号作为常规字符，而不是字符串分隔符。应该像处理常规字符（如Q）那样处理转义序列（如\n）。
Ctr+Z的ASCII码为26，对应的八进制编码为032，十六进制编码为0x1a。可以用下面的转义序列来表示该字符：\032或\x1a。将这些编码用单引号括起，可以得到相应的字符常量，如'\032'，也可以将它们放在字符串中，如"hi\x1a there"。
#### 通用字符名
C++实现支持一个基本的源字符集，即可用来编写源代码的字符集。
C++有一种表示这种特殊字符的机制，它独立于任何特定的键盘，使用的是通用字符名（universal character name）。
还有一个基本的执行字符集，它包括在程序执行期间可处理的字符（如可从文件中读取或显示到屏幕上的字符）。
通用字符名可以以\u或\U打头。\u后面是8个十六进制位，\U后面则是16个十六进制位。这些位表示的是字符的ISO 10646码点
```
int k\u00F6rper;
cout << "Let them eat g\u00E2teau.\n";
```
请注意，C++使用术语“通用编码名”，而不是“通用编码”，这是因为应将\u00F6解释为“Unicode码点为U-00F6的字符”。
#### signed char和unsigned char
char是否有符号由C++实现决定 可以显式地将类型设置为signed char 或unsigned char：
#### wcha_t
程序需要处理的字符集可能无法用一个8位的字节表示。
C++的处理方式有两种。首先，如果大型字符集是实现的基本字符集，则编译器厂商可以将char定义为一个16位的字节或更长的字节。其次，一种实现可以同时支持一个小型基本字符集和一个较大的扩展字符集。8位char可以表示基本字符集，另一种类型wchar_t（宽字符类型）可以表示扩展字符集。这种类型与另一种整型（底层（underlying）类型）的长度和符号属性相同。
cin和cout将输入和输出看作是char流，因此不适于用来处理wchar_t类型。iostream头文件的最新版本提供了作用相似的工具—wcin和wcout，可用于处理wchar_t流。另外，可以通过加上前缀L来指示宽字符常量和宽字符串。
```
wchat_t bob = L'P';
wcout << L"tall" << end;
```
#### C++11新增的类型：char16_t和char32_t
C++11新增了类型char16_t和char32_t，其中前者是无符号的，长16位，而后者也是无符号的，但长32位。C++11使用前缀u表示char16_t字符常量和字符串常量，如u‘C’和u“be good”；并使用前缀U表示char32_t常量，如U‘R’和U“dirty rat”。类型char16_t与/u00F6形式的通用字符名匹配，而类型char32_t与/U0000222B形式的通用字符名匹配。前缀u和U分别指出字符字面值的类型为char16_t和char32_t

### 3.1.9 bool类型
过去，C++和C一样，也没有布尔类型。现在可以使用bool类型来表示真和假了，它们分别用预定义的字面值true和false表示。字面值true和false都可以通过提升转换为int类型，true被转换为1，而false被转换为0：另外，任何数字值或指针值都可以被隐式转换（即不用显式强制转换）为bool值。任何非零值都被转换为true，而零被转换为false：
```
bool is_ready = true;

int ans = true;
int promise = false;

bool start = -100;
bool stop = 0;
```
## 3.2 const限定符
符号名称指出了常量表示的内容。另外，如果程序在多个地方使用同一个常量，则需要修改该常量时，只需修改一个符号定义即可。
使用const关键字来修改变量声明和初始化。

`const int Months = 12;`

常量（如Months）被初始化后，其值就被固定了，编译器将不允许再修改该常量的值。关键字const叫做**限定符**，因为它限定了声明的含义。
创建常量的通用格式如下：

`const type name = value;`

应在声明中对const进行初始化。如果在声明常量时没有提供值，则该常量的值将是不确定的，且无法修改。可以使用C++的作用域规则将定义限制在特定的函数或文件中,在C++（而不是C）中可以用const值来声明数组长度
## 3.3 浮点数
浮点数能够表示带小数部分的数字
计算机将这样的值分成两部分存储。一部分表示值，另一部分用于对值进行放大或缩小。缩放因子的作用是移动小数点的位置，术语浮点因此而得名。
### 3.3.1 书写浮点数
12.34;939001.32;0.00023;8.0;
第二种表示浮点值的方法叫做E表示法
2.52e+8;8.33E-4;7E5;-18.32e13;1.69e12;5.98E24;9.11e-31;
E表示法确保数字以浮点格式存储，即使没有小数点。注意，既可以使用E也可以使用e，指数可以是正数也可以是负数。然而，数字中不能有空格，因此7.2 E6是非法的。
### 3.3.2 浮点类型
float、double和long double。
这些类型是按它们可以表示的有效数位和允许的指数最小范围来描述的。**有效位**（significant figure）是数字中有意义的位。
float至少32位，double至少48位，且不少于float，long double至少和double一样多。这三种类型的有效位数可以一样多。然而，通常，float为32位，double为64位，long double为80、96或128位。
这3种类型的指数范围至少是−37到37。
通常cout会删除结尾的零。调用cout.setf( )将覆盖这种行为，float的精度比double低。在7位有效位上还是精确的,double类型至少有13位是精确的.
cout所属的ostream类有一个类成员函数，能够精确地控制输出的格式—字段宽度、小数位数、采用小数格式还是E格式等。
### 3.3.3 浮点常量
在默认情况下，像8.24和2.4E8这样的浮点常量都属于double类型。如果希望常量为float类型，请使用f或F后缀。对于long double类型，可使用l或L后缀
### 3.3.4 浮点数的优缺点
浮点运算的速度通常比整数运算慢，且精度将降低。
## 3.4 C++算术运算符
种基本的算术计算：加法、减法、乘法、除法以及求模。每种运算符都使用两个值（操作数）来计算结果。运算符及其操作数构成了表达式。
- +运算符对操作数执行加法运算。例如，4+20等于24。
- −运算符从第一个数中减去第二个数。例如，12−3等于9。
- *运算符将操作数相乘。例如，28*4等于112。
- /运算符用第一个数除以第二个数。例如，1000/5等于200。如果两个操作数都是整数，则结果为商的整数部分。例如，17/3等于5，小数部分被丢弃。
- %运算符求模。也就是说，它生成第一个数除以第二个数后的余数。例如，19%6为1，因为19是6的3倍余1。两个操作数必须都是整型，将该运算符用于浮点数将导致编译错误。如果其中一个是负数，则结果的符号满足如下规则：(a/b)*b + a%b ＝ a。
### 3.4.1 运算符优先级和结合性
算术运算符遵循通常的代数优先级，先乘除，后加减。可以使用括号来执行自己定义的优先级。
当两个运算符的优先级相同时，C++将看操作数的**结合性**（associativity）是从左到右，还是从右到左。
注意，仅当两个运算符被用于同一个操作数时，优先级和结合性规则才有效。
### 3.4.2 除法分支
如果两个操作数都是整数，则C++将执行整数除法。
如果其中有一个（或两个）操作数是浮点值，则小数部分将保留，结果为浮点数。
如果两个操作数都是double类型，则结果为double类型；如果两个操作数都是float类型，则结果为float类型。
### 3.4.3 求模运算符
求模运算符返回整数除法的余数。
### 3.4.4 类型转换
C++自动执行很多类型转换
- 将一种算术类型的值赋给另一种算术类型的变量时，C++将对值进行转换；
- 表达式中包含不同的类型时，C++将对值进行转换；
- 将参数传递给函数时，C++将对值进行转换。
#### 初始化和赋值进行的转换
C++允许将一种类型的值赋给另一种类型的变量。这样做时，值将被转换为接收变量的类型。
将0赋给bool变量时，将被转换为false；而非零值将被转换为true。
将浮点值赋给整型将导致两个问题。首先，将浮点值转换为整型会将数字截短（除掉小数部分）。其次，float值对于int变量来说可能太大了。
将浮点型转换为整型时，C++采取截取（丢弃小数部分）而不是四舍五入（查找最接近的整数）。
#### 以{ }方式初始化时进行的转换（C++11）
C++11将使用大括号的初始化称为**列表初始化**
列表初始化不允许缩窄（narrowing），即变量的类型可能无法表示赋给它的值。
```
char c1 {31325};
char c2 = {66};

```
#### 表达式中的转换
一些类型在出现时便会自动转换；其次，有些类型在与其他类型同时出现在表达式中时将被转换。
在计算表达式时，C++将bool、char、unsignedchar、signed char和short值转换为int。这些转换被称为整型提升（integral promotion）。
如果short比int短，则unsigned short类型将被转换为int；如果两种类型的长度相同，则unsigned short类型将被转换为unsigned int。
wchar_t被提升成为下列类型中第一个宽度足够存储wchar_t取值范围的类型：int、unsigned int、long或unsigned long。
当运算涉及两种类型时，较小的类型将被转换为较大的类型。
下面是C++11版本的校验表
1. 如果有一个操作数的类型是long double，则将另一个操作数转换为long double。
2. 否则，如果有一个操作数的类型是double，则将另一个操作数转换为double。
3. 否则，如果有一个操作数的类型是float，则将另一个操作数转换为float。
4. 否则，说明操作数都是整型，因此执行整型提升。
5. 在这种情况下，如果两个操作数都是有符号或无符号的，且其中一个操作数的级别比另一个低，则转换为级别高的类型。
6. 如果一个操作数为有符号的，另一个操作数为无符号的，且无符号操作数的级别比有符号操作数高，则将有符号操作数转换为无符号操作数所属的类型。
7. 否则，如果有符号类型可表示无符号类型的所有可能取值，则将无符号操作数转换为有符号操作数所属的类型。
8. 否则，将两个操作数都转换为有符号类型的无符号版本。
9. 简单地说，有符号整型按级别
从高到低依次为long long、long、int、short和signed char。无符号整型的排列顺序与有符号整型相同。类型char、signed char和unsigned char的级别相同。类型bool的级别最低。wchar_t、char16_t和char32_t的级别与其底层类型相同。
#### 传递参数时的转换
传递参数时的类型转换通常由C++函数原型控制。
#### 强制类型转换
强制类型转换的格式有两种。
```
(long) thorn
long (thorn)
```
强制类型转换不会修改thorn变量本身，而是创建一个新的、指定类型的值，可以在表达式中使用这个值。
```
(typeName) value
typeName (value)
```
C++还引入了4个强制类型转换运算符，对它们的使用要求更为严格
static_cast<>可用于将值从一种数值类型转换为另一种数值类型。
```
static_cast<typeName> (value)
```
### 3.4.5 C++11中的auto声明
C++11新增了一个工具，让编译器能够根据初始值的类型推断变量的类型。在初始化声明中，如果
使用关键字auto，而不指定变量的类型，编译器将把变量的类型设置成与初始值相同：
如标准模块库（STL）中的类型时，自动类型推断有时才能显现出来。
## 3.5 总结
