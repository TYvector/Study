# 第5章 循环和关系表达式
## 5.1 for循环
循环的初始化（loop initialization）。循环测试（loop test）。循环体（loop body）。循环更新（loop update）。++运算符—递增运算符（increment operator）。
### 5.1.1 for循环的组成部分
for循环的组成部分完成下面这些步骤。
1. 设置初始值。
2. 执行测试，看看循环是否应当继续进行。
3. 执行循环操作。
4. 更新用于测试的值。
初始化、测试和更新操作构成了控制部分，这些操作由括号括起。其中每部分都是一个表达式，彼此由分号隔开。控制部分后面的语句叫作循环体，只要测试表达式为true，它便被执行：
```
for (initialization; test-expression; update-expression)
body
```
C++语法将整个for看作一条语句—虽然循环体可以包含一条或多条语句。（包含多条语句时，需要使用复合语句或代码块，这将在本章后面进行讨论。）

循环只执行一次初始化。通常，程序使用该表达式将变量设置为起始值，然后用该变量计算循环周期。

test-expression（测试表达式）决定循环体是否被执行。通常，这个表达式是关系表达式，即对两个值进行比较。

for循环是入口条件（entry-condition）循环。这意味着在每轮循环之前，都将计算测试表达式的值，当测试表达式为false时，将不会执行循环体。

update-expression（更新表达式）在每轮循环结束时执行，此时循环体已经执行完毕。

for是一个C++关键字，因此编译器不会将for视为一个函数，这还将防止将函数命名为for。
1. 表达式和语句
任何值或任何有效的值和运算符的组合都是表达式。在C++中，**每个表达式都有值**。C++将赋值表达式的值定义为左侧成员的值。赋值运算符是从右向左结合的。

通常，cout在显示bool值之前将它们转换为int，但cout.setf（ios::boolalpha）函数调用设置了一个标记，该标记命令cout显示true和false，而不是1和0。

当判定表达式的值这种操作改变了内存中数据的值时，我们说表达式有副作用（side effect）。判定赋值表达式会带来这样的副作用，即修改被赋值者的值。有可能把赋值看作预期的效果，但从C++的构造方式这个角度来看，判定表达式才是主要作用。

从表达式到语句的转变很容易，只要加分号即可。只要加上分号，所有的表达式都可以成为语句，但不一定有编程意义。
2. 非表达式和语句
从语句中删除分号，并不一定能将它转换为表达式。
3. 修改规则
可以在for循环的初始化部分中声明变量。声明不是表达式。for语句的句法修改成下面这样：
```
for (for-init-statement condition; expression)
```
for-init-statement被视为一条语句，而语句有自己的分号。对于for-init-statement来说，它既可以是表达式语句，也可以是声明。在for-init-statement中声明变量还有其实用的一面，这种变量只存在于for语句中，也就是说，当程序离开循环后，这种变量将消失。
### 5.1.2 回到for循环
表达式i < ArSize反映了这样一个事实，包含ArSize个元素的数组的下标从0到ArSize – 1，因此数组索引应在ArSize减1的位置停止。
### 5.1.3 修改步长
更新表达式可以是任何有效的表达式。
### 5.1.4 使用for循环访问字符串
for循环提供了一种依次访问字符串中每个字符的方式。string类的size( )获得字符串中的字符数；
### 5.1.5 递增运算符（++）和递减运算符（−−）
这两个运算符执行两种极其常见的循环操作：将循环计数加1或减1。前缀（prefix）版本位于操作数前面，如++x；后缀（postfix）版本位于操作数后面，如x++。两个版本对操作数的影响是一样的，但是影响的时间不同。
a++意味着使用a的当前值计算表达式，然后将a的值加1；而++b的意思是先将b的值加1，然后使用新的值来计算表达式。
### 5.1.6 副作用和顺序点
副作用（side effect）指的是在计算表达式时对某些东西（如存储在变量中的值）进行了修改；顺序点（sequence point）是程序执行过程中的一个点，在这里，进入下一步之前将确保对所有的副作用都进行了评估。在C++中，语句中的分号就是一个顺序点，这意味着程序处理下一条语句之前，赋值运算符、递增运算符和递减运算符执行的所有修改都必须完成。任何完整的表达式末尾都是一个顺序点。

何为完整表达式呢？它是这样一个表达式：不是另一个更大表达式的子表达式。完整表达式的例子有：表达式语句中的表达式部分以及用作while循环中检测条件的表达式。

在C++11文档中，不再使用术语“顺序点”了，因为这个概念难以用于讨论多线程执行。相反，使用了术语“顺序”，它表示有些事件在其他事件前发生。这种描述方法并非要改变规则，而旨在更清晰地描述多线程编程。
### 5.1.7 前缀格式和后缀格式
对于内置类型，采用哪种格式不会有差别；但对于用户定义的类型，如果有用户定义的递增和递减运算符，则前缀格式的效率更高。
### 5.1.8 递增/递减运算符和指针
将递增运算符用于指针时，将把指针的值增加其指向的数据类型占用的字节数，这种规则适用于对指针递增和递减：
也可以结合使用这些运算符和*运算符来修改指针指向的值。前缀递增、前缀递减和解除引用运算
符的优先级相同，以从右到左的方式进行结合。后缀递增和后缀递减的优先级相同，但比前缀运算符的优先级高，这两个运算符以从左到右的方式进行结合。

前缀运算符的从右到到结合规则意味着*++pt的含义如下：现将++应用于pt（因为++位于* 的右边），然后将*应用于被递增后的pt。++ *pt意味着先取得pt指向的值，然后将这个值加1。
### 5.1.9 组合赋值运算符
+=运算符将两个操作数相加，并将结果赋给左边的操作数。这意味着左边的操作数必须能够被赋值，如变量、数组元素、结构成员或通过对指针解除引用来标识的数据。
每个算术运算符都有其对应的组合赋值运算符，每个运算符的工作方式都和+=相似。
### 5.1.10 复合语句（语句块）
方法是用两个花括号来构造一条复合语句（代码块）。代码块由一对花括号和它们包含的语句组成，被视为一条语句，从而满足句法的要求。
复合语句还有一种有趣的特性。如果在语句块中定义一个新的变量，则仅当程序执行该语句块中的语句时，该变量才存在。执行完该语句块后，变量将被释放。这表明此变量仅在该语句块中才是可用的。

如果在一个语句块中声明一个变量，而外部语句块中也有一个这种名称的变量，情况将如何呢？在声明位置到内部语句块结束的范围之内，新变量将隐藏旧变量；然后就变量再次可见。
### 5.1.11 其他语法技巧—逗号运算符
语句块允许把两条或更多条语句放到按C++句法只能放一条语句的地方。逗号运算符对表达式完成同样的任务，允许将两个表达式放到C++句法只允许放一个表达式的地方。

可以使用逗号运算符将两个表达式合并为一个.
```
++j, --i
```
可以使用一个声明语句表达式来创建并初始化两个变量，但是这样看起来有些乱。在这种情况下，逗号只是一个列表分隔符，而不是逗号运算符，因此该表达式对j和i进行声明和初始化。

它确保先计算第一个表达式，然后计算第二个表达式（换句话说，逗号运算符是一个顺序点）。其次，C++规定，逗号表达式的值是第二部分的值。

在所有运算符中，逗号运算符的优先级是最低的。
### 5.1.12 关系表达式
C++提供了6种关系运算符来对数字进行比较。由于字符用其ASCII码表示，因此也可以将这些运算符用于字符。不能将它们用于C-风格字符串，但可用于string类对象。

<,<=,==,>,>=,!=

关系运算符的优先级比算术运算符低。
### 5.1.13 赋值、比较和可能犯的错误
不要混淆等于运算符（= =）与赋值运算符（=）。
```
musicians == 4;     //comparison  true/false
musicians = 4;      //assignment  4
```
发现这种错误的困难之处在于，代码在语法上是正确的，因此编译器不会将其视为错误（然而，由于C和C++程序员频繁地犯这种错误，因此很多编译器都会发出警告，询问这是否是设计者的真正意图）。
### 5.1.14 C-风格字符串的比较
假设要知道字符数组中的字符串是不是mate。如果word是数组名，下面的测试可能并不能像我们预想的那样工作：
```
word == "mate";
```
上面的关系表达式不是判断两个字符串是否相同，而是查看它们是否存储在相同的地址上。

应使用C-风格字符串库中的strcmp( )函数来比较。该函数接受两个字符串地址作为参数。这意味着参数可以是指针、字符串常量或字符数组名。如果两个字符串相同，该函数将返回零；如果第一个字符串按字母顺序排在第二个字符串之前，则strcmp( )将返回一个负数值；如果第一个字符串按字母顺序排在第二个字符串之后，则strcpm( )将返回一个正数值。

字符是根据字符的系统编码来进行比较的。使用ASCII码时，所有大写字母的编码都比小写字母小，所以按排列顺序，大写字母将位于小写字母之前。

两个字符串即使被存储在长度不同的数组中，也可能是相同的。

虽然不能用关系运算符来比较字符串，但却可以用它们来比较字符，因为字符实际上是整型。可以对字符变量使用递增运算符和递减运算符，因为char类型实际上是整型，因此这种操作实际上将修改存储在变量中的整数编码。
### 5.1.15 比较string类字符串
如果使用string类字符串而不是C-风格字符串，比较起来将简单些，因为类设计让您能够使用关系运算符进行比较。这之所以可行，是因为类函数重载（重新定义）了这些运算符。
```
word!="mate"
```
string类重载运算符!=的方式让您能够在下述条件下使用它：至少有一个操作数为string对象，另一个操作数可以是string对象，也可以是C-风格字符串。
string类的设计让您能够将string对象作为一个实体（在关系型测试表达式中），也可以将其作为一个聚合对象，从而使用数组表示法来提取其中的字符。
## 5.2 while循环
while循环是没有初始化和更新部分的for循环，它只有测试条件和循环体：
```
while (test-condition)
    body
```
首先，程序计算圆括号内的测试条件（test-condition）表达式。如果该表达式为true，则执行循环体中的语句。。和for循环一样，while循环也是一种入口条件循环。因此，如果测试条件一开始便为false，则程序将不会执行循环体。
### 5.2.1 for与while
在C++中，for和while循环本质上是相同的。
```
for (init-expression; test-expression; update-expression)
{
    statement(s)
}

init-expression;
while (test-expression)
{
    statement(S)
    update-expression;
}
```
for循环需要3个表达式，不过它们可以是空表达式（语句），只有两个分号是必需的。

由于for循环和while循环几乎是等效的，因此究竟使用哪一个只是风格上的问题。它们之间存在三个差别。首先，在for循环中省略了测试条件时，将认为条件为true；其次，在for循环中，可使用初始化语句声明一个局部变量，但在while循环中不能这样做；最后，如果循环体中包括continue语句，情况将稍有不同。程序员使用for循环来为循环计数，因为for循环格式允许将所有相关的信息—初始值、终止值和更新计数器的方法—放在同一个地方。在无法预先知道循环将执行的次数时，程序员常使用while循环。

在设计循环时，请记住下面几条指导原则。
- 指定循环终止的条件。
- 在首次测试之前初始化条件。
- 在条件被再次测试之前更新条件。
### 5.2.2 等待一段时间：编写延时循环
ANSI C和C++库中有一个函数有助于完成这样的工作。这个函数名为clock( )，返回程序开始执行后所用的系统时间。
头文件ctime（较早的实现中为time.h）提供了这些问题的解决方案。首先，它定义了一个符号常量—CLOCKS_PER_SEC，该常量等于每秒钟包含的系统时间单位数。因此，将系统时间除以这个值，可以得到秒数。或者将秒数乘以CLOCK_PER_SEC，可以得到以系统时间单位为单位的时间。其次，ctime将clock_t作为clock( )返回类型的别名（参见本章后面的注释“类型别名”），这意味着可以将变量声明为clock_t类型，编译器将把它转换为long、unsigned int或适合系统的其他类型。

C++为类型建立别名的方式有两种。一种是使用预处理器：
```
#define BYTE char

typedef char byte;
typedef typeName aliasName;
```
如果要将aliasName作为某种类型的别名，可以声明aliasName，如同将aliasName声明为这种类型的变量那样，然后在声明的前面加上关键字typedef。例如，要让byte_pointer成为char指针的别名，可将byte_pointer声明为char指针，然后在前面加上typedef：
```
typedef char * byte_pointer;
```
## 5.3 do while循环
它是出口条件（exit condition）循环。这意味着这种循环将首先执行循环体，然后再判定测试表达式，决定是否应继续执行循环。
```
do
    body
while (test-expression);
```
## 5.4 基于范围的for循环（C++11）
C++11新增了一种循环：基于范围（range-based）的for循环。这简化了一种常见的循环任务：对数组（或容器类，如vector和array）的每个元素执行相同的操作，如下例所示：
```
double prices[5] = {4.99, 10.99, 6.87, 7.99, 8.49};
for (double x:price)
    cout << x << std::endl;
```
其中，x最初表示数组prices的第一个元素。显示第一个元素后，不断执行循环，而x依次表示数组的其他元素。因此，上述代码显示全部5个元素，每个元素占据一行。总之，该循环显示数组中的每个值。
要修改数组的元素，需要使用不同的循环变量语法：
```
for (double &x : prices)
    x = x * 0.80;
```
符号&表明x是一个引用变量。就这里而言，这种声明让接下来的代码能够修改数组的内容，而第一种语法不能。
```
for (int x :{3, 5, 2, 8, 6})
    cout << x;
```
## 5.5 循环和文本输入
逐字符地读取来自文件或键盘的文本。cin对象支持3种不同模式的单字符输入，其用户接口各不相同。
### 5.5.1 使用原始的cin进行输入
如果程序要使用循环来读取来自键盘的文本输入，则必须有办法知道何时停止读取。一种方法是选择某个特殊字符—有时被称为哨兵字符（sentinel character），将其作为停止标记。

读取char值时，与读取其他基本类型一样，cin将忽略空格和换行符。因此输入中的空格没有被回显，也没有被包括在计数内。
### 5.5.2 使用cin.get(char)进行补救
成员函数cin.get(ch)读取输入中的下一个字符（即使它是空格），并将其赋给变量ch。在C语言中，要修改变量的值，必须将变量的地址传递给函数。但调用cin.get( )时，传递的是ch，而不是&ch。在C++中有效，只要函数将参数声明为引用即可。
### 5.5.3 使用哪一个cin.get( )
```
cin.get(name,ArSize).get();
```
```
cin.get(name,ArSize);
cin.get();
```

cin.get( )的一个版本接受两个参数：数组名（字符串（char* 类型）的地址）和ArSize（int类型的整数）。（记住，数组名是其第一个元素的地址，因此字符数组名的类型为char*。）接下来，程序使用了不接受任何参数的cin.get( )。
函数重载允许对多个相关的函数使用相同的名称，这些函数以不同方式或针对不同类型执行相同的基本任务。
### 5.5.4 文件尾条件
如果输入来自于文件，则可以使用一种功能更强大的技术—检测文件尾（EOF）。C++输入工具和操作系统协同工作，来检测文件尾并将这种信息告知程序。

很多操作系统（包括Unix、Linux和Windows命令提示符模式）都支持重定向，允许用文件替换键盘输入。很多操作系统都允许通过键盘来模拟文件尾条件。在Unix中，可以在行首按下Ctrl+D来实现；在Windows命令提示符模式下，可以在任意位置按Ctrl+Z和Enter。

检测到EOF后，cin将两位（eofbit和failbit）都设置为1。可以通过成员函数eof( )来查看eofbit是否被设置；如果检测到EOF，则cin.eof( )将返回bool值true，否则返回false。同样，如果eofbit或failbit被设置为1，则fail( )成员函数返回true，否则返回false。注意，eof( )和fail( )方法报告最近读取的结果；也就是说，它们在事后报告，而不是预先报告。因此应将cin.eof( )或cin.fail( )测试放在读取后。
1. EOF结束输入
cin方法检测到EOF时，将设置cin对象中一个指示EOF条件的标记。设置这个标记后，cin将不读取输入，再次调用cin也不管用。对于文件输入，这是有道理的，因为程序不应读取超出文件尾的内容。然而，对于键盘输入，有可能使用模拟EOF来结束循环，但稍后要读取其他输入。cin.clear( )方法可能清除EOF标记，使输入继续进行。不过要记住的是，在有些系统中，按Ctrl+Z实际上将结束输入和输出，而cin.clear( )将无法恢复输入和输出。
2. 常见的字符输入做法
```
cin.get(ch);
while (cin.fail() == false)
{
    ...
    cin.get(ch);
}
```
方法cin.get(char)的返回值是一个cin对象。然而，istream类提供了一个可以将istream对象（如cin）转换为bool值的函数；当cin出现在需要bool值的地方（如在while循环的测试条件中）时，该转换函数将被调用。另外，如果最后一次读取成功了，则转换得到的bool值为true；否则为false。这意味着可以将上述while测试改写为这样：
```
while (cin)
```
由于cin.get(char)的返回值为cin，因此可以将循环精简成这种格式：
```
while (cin.get(ch))
```
三条指导原则（确定结束条件、对条件进行初始化以及更新条件）全部被放在循环测试条件中。
### 5.5.5 另一个cin.get( )版本
getchar( )和putchar( )，它们仍然适用，只要像在C语言中那样包含头文件stdio.h（或新的cstdio）即可。
不接受任何参数的cin.get( )成员函数返回输入中的下一个字符。
```
ch = cin.get();
```
该函数的工作方式与C语言中的getchar( )相似，将字符编码作为int值返回；而cin.get(ch)返回一个对象，而不是读取的字符。同样，可以使用cout.put( )函数（参见第3章）来显示字符：
```
cout.put(ch);
```
该函数的工作方式类似C语言中的putchar( )，只不过其参数类型为char，而不是int。
为成功地使用cin.get( )，需要知道其如何处理EOF条件。当该函数到达EOF时，将没有可返回的字符。相反，cin.get( )将返回一个用符号常量EOF表示的特殊值。该常量是在头文件iostream中定义的。EOF值必须不同于任何有效的字符值，以便程序不会将EOF与常规字符混淆。通常，EOF被定义为值−1，因为没有ASCII码为−1的字符，但并不需要知道实际的值，而只需在程序中使用EOF即可。

由于EOF表示的不是有效字符编码，因此可能不与char类型兼容。例如，在有些系统中，char类型是没有符号的，因此char变量不可能为EOF值（−1）。由于这种原因，如果使用cin.get( )（没有参数）并测试EOF，则必须将返回值赋给int变量，而不是char变量。另外，如果将ch的类型声明为int，而不是char，则必须在显示ch时将其强制转换为char类型。

由于EOF表示的不是有效字符编码，因此可能不与char类型兼容。例如，在有些系统中，char类型是没有符号的，因此char变量不可能为EOF值（−1）。由于这种原因，如果使用cin.get( )（没有参数）并测试EOF，则必须将返回值赋给int变量，而不是char变量。另外，如果将ch的类型声明为int，而不是char，则必须在显示ch时将其强制转换为char类型。
使用字符参数的版本更符合对象方式，因为其返回值是istream对象。这意味着可以将它们拼接起来。代码将输入中的下一个字符读入到ch1中，并将接下来的一个字符读入到ch2中:
```
cin.get(ch1).get(ch2);
```
## 5.6 嵌套循环和二维数组
二维数组更像是一个表格—既有数据行又有数据列。
```
int maxtemps[4][5];
```
该声明意味着maxtemps是一个包含4个元素的数组，其中每个元素都是一个由5个整数组成的数组。可以将maxtemps数组看作由4行组成，其中每一行有5个温度值。
### 5.6.1 初始化二维数组
```
int maxtemps[4][5] = 
{
    {96, 100, 87, 101, 105},
    {96, 98, 91, 107, 104},
    {97, 101, 93, 108, 107},
    {98, 103, 95, 109, 108}
};
```
### 5.6.2 使用二维数组
还采用了C++常用的做法，将一个指针数组初始化为一组字符串常量。这使得每个元素（如cities [0]）都是一个char指针，可被初始化为一个字符串的地址。程序将cities [0]初始化为字符串“GribbleCity”的地址，等等。
```
const char * cities[Cities] = 
{
    "Gribble City",
    "Gribbletown",
    ....
};
```
另外，还可以使用string对象数组，而不是字符串指针数组。
如果希望字符串是可修改的，则应省略限定符const。在希望字符串是可修改的情况下，string类自动调整大小的特性将使这种方法比使用二维数组更为方便。
## 5.7 总结
1. C++提供了3种循环：for循环、while循环和do while循环。如果循环测试条件为true或非零，则循环将重复执行一组指令；如果测试条件为false或0，则结束循环。for循环和while循环都是入口条件循环，这意味着程序将在执行循环体中的语句之前检查测试条件。do while循环是出口条件循环，这意味着其将在执行循环体中的语句之后检查条件。
2. 每种循环的句法都要求循环体由一条语句组成。然而，这条语句可以是复合语句，也可以是语句块（由花括号括起的多条语句）。
3. 关系表达式对两个值进行比较，常被用作循环测试条件。关系表达式是通过使用6种关系运算符之一构成的：<、<=、= =、>=、>或! =。关系表达式的结果为bool类型，值为true或false。
4. 许多程序都逐字节地读取文本输入或文本文件，istream类提供了多种可完成这种工作的方法。
```
cin >> ch;
cin.get(ch);
ch = cin.get();
```
5. cin.get（char）成员函数调用通过返回转换为false的bool值来指出已到达EOF，而cin.get( )成员函数调用则通过返回EOF值来指出已到达EOF，EOF是在文件iostream中定义的。
6. 嵌套循环是循环中的循环，适合用于处理二维数组。
